<h1 align="center"> Linux Capabilities Enumeration </h1>







# Introduction

## What is Linux Capabilities?

### The Evolution:
- Old Way: SUID binaries - All or nothing root access
- New Way: Capabilities - Fine-grained privileges


## What are Capabilities?
Capabilities break down root privileges into smaller, specific permissions. Instead of giving a program full root access (SUID), you can grant only the specific privileges it needs.


## Why Capabilities Master for Privileges Escalation:
- More common in modern systems
- Often misconfigured
- Less monitored than SUID binaries
- Can provide root-level access if exploited
- Harder to detect than traditional SUID





---




# Linux Capabilities Enumeration:

## 1. Reconnaissance & Crack SSH
- First in this i scan to our target:
````
nmap 192.168.127.131 -sV -T4
````
<img width="1191" height="275" alt="image" src="https://github.com/user-attachments/assets/ec5c743a-da1d-45cc-a2aa-15b241c99065" />


- After i crack this target `SSH Port`:
````
hydra -L /usr/share/wordlists/user.txt -P /usr/share/wordlists/passwd.txt -t 4 -s 22 192.168.127.131 ssh -V -f
````
````
hydra -l k4n0ng -P /usr/share/wordlists/passwd.txt -t 4 -s 22 192.168.127.131 ssh -V -f
````
<img width="1902" height="518" alt="image" src="https://github.com/user-attachments/assets/797181c5-9a89-4cbc-ad3d-45d00cb23a42" />


- Now we found the correct `Password`, and after I login to it:
````
ssh k4n0ng@192.168.127.131
````
<img width="720" height="425" alt="image" src="https://github.com/user-attachments/assets/600da6aa-45af-4b1e-99d2-9090eea4403c" />

- Now we was access to our target `ssh port`.

---




## 2. What are Capabilities in Linux?
### Capabilities Sets
Each process has three capability sets:
- **Inheritable (i)**: Capabilities preserved across execve()
- **Effective (e)**: Currently active capabilities
- **Permitted (p)**: Capabilities that can be made effective
- **Bounding**: Limits what can be added to permitted
- **Ambient**: Inherited across exec calls


### Traditional UNIX vs. Linux Capabilities
- Traditional UNIX:
  - Privileged: euid = 0
  - Unprivileged: euid ≠ 0
- Linux (Kernel ≥ 2.2):
  - Privileges are split into distinct units called capabilities
  - These can be enabled or disabled per thread

**Purpose**: Capabilities implement the least privilege design principle — giving processes only the permissions they need.



````
getcap /usr/bin/ping
````
<img width="469" height="130" alt="image" src="https://github.com/user-attachments/assets/cf4561fa-2779-4ee4-8eba-90b729dea56e" />

- `getcap /usr/bin/ping`: This checks what Linux capabilities are assigned to the ping binary.
- `cap_net_raw`: This capability allows a process to use raw sockets, which are required for sending ICMP packets — the core of what `ping` does.
- `=ep`:
  - `e`: Effective: The capability is active and usable.
  - `p`: Permitted: The process is allowed to use it if needed.



#### Website that we should know:
- man7: https://man7.org/linux/man-pages/man7/capabilities.7.html
<img width="875" height="1026" alt="image" src="https://github.com/user-attachments/assets/85f9c8a2-670a-49fe-9690-74e61efcee92" />

- Hacktricks: https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities

- But in this my browser was block it.

---





## 3. Configuration


### What is Configuration?
Configuration of capability enumeration in Linux involves listing, assigning, and modifying capabilities on executables or processes using tools like `getcap`, `setcap`, and `capsh`. This allows you to control which fine‑grained privileges a binary or process can use, instead of granting full root access.


### Listing Capabilities

#### For executables:
````
getcap /usr/bin/ping
````
<img width="396" height="100" alt="image" src="https://github.com/user-attachments/assets/c69dc03e-1e07-45e2-b255-109ca7155f51" />

- In this it will show assigned capabilities `cap_net_raw=ep`.

#### For processes
- Find the Process ID (PID):
````
ps aux | grep ping
````
<img width="987" height="110" alt="image" src="https://github.com/user-attachments/assets/95ee5b5e-dcd2-410c-a1fe-301e1df5c318" />

- Line 1:
  - **PID** `2716`: This is the `gsd-housekeeping` process (part of GNOME system services).
  - It’s not `ping`, but it showed up because its command line contains the string `ping`.
- Line 2:
  - **PID** `15515`: This is the `grep` command you just ran (`grep ping`).
  - It matches itself because the word “ping” is in its arguments.


---




## 4. Finding Capabilities

### Basic Enumeration:
#### Find all files with capabilities
````
getcap -r / 2>/dev/null
````
<img width="1726" height="295" alt="image" src="https://github.com/user-attachments/assets/dc0e274d-d9ac-411c-b8d7-8be358736cee" />



#### Using find command
````
find / -type f -exec getcap {} \; 2>/dev/null
````
<img width="1724" height="290" alt="image" src="https://github.com/user-attachments/assets/155ab0b8-9da9-43da-83f0-48a864154714" />



#### Check specific directories
````
getcap -r /usr/bin /usr/sbin /bin /sbin 2>/dev/null
````
<img width="687" height="140" alt="image" src="https://github.com/user-attachments/assets/f8430d3c-ddfb-412e-b35e-53b36eb19a5f" />




## 5. Enumeration automated script:

#### System-Wide Capability
````
# SYSTEM-WIDE CAPABILITY SEARCH
echo "=== 1. ALL FILES WITH CAPABILITIES ==="
getcap -r / 2>/dev/null | while read line; do
    echo "$line"
done
echo ""
````
<img width="1741" height="410" alt="image" src="https://github.com/user-attachments/assets/fc87e18d-123b-442d-be65-dfb86c144f6a" />

- Recursively lists all files with capabilities set.

- This script we can create `.sh` file or we can copy this and past to `Terminal`:
````
nano sys_wide.sh
````
````
# SYSTEM-WIDE CAPABILITY SEARCH
echo "=== 1. ALL FILES WITH CAPABILITIES ==="
getcap -r / 2>/dev/null | while read line; do
    echo "$line"
done
echo ""
````
<img width="1041" height="402" alt="image" src="https://github.com/user-attachments/assets/4a219fd8-fe23-4962-8716-2e9288de2f89" />

- to exit press `Ctrl + O` -> `Enter` -> `Ctrl + X`.

- Executive:
````
chmod +x sys_wide.sh
````
<img width="380" height="128" alt="image" src="https://github.com/user-attachments/assets/77b7e142-9244-44ef-81c2-da69858587f3" />


- Run
````
./sys_wide.sh
````
<img width="1747" height="297" alt="image" src="https://github.com/user-attachments/assets/e77b45da-c8d8-4e77-b88b-06de89099ed1" />




#### Dangerous Capabilities:
````
echo "=== DANGEROUS CAPABILITIES FOUND ==="
DANGEROUS_CAPS="cap_dac_read_search|cap_dac_override|cap_setuid|cap_setgid|cap_sys_admin|cap_sys_ptrace|cap_sys_module"

getcap -r / 2>/dev/null | while read line; do
    if echo "$line" | grep -q -E "$DANGEROUS_CAPS"; then
        echo "[!] DANGEROUS: $line"
    fi
done
echo ""
````
<img width="1886" height="293" alt="image" src="https://github.com/user-attachments/assets/5f987b90-721d-48ee-9013-1edebd7adcbf" />


- Flags binaries with high‑risk capabilities that could be abused





#### Current Process Capabilities
````
# PROCESS CAPABILITIES
echo "=== 4. CURRENT PROCESS CAPABILITIES ==="
echo "Current PID: $$"
cat /proc/$$/status | grep -i cap
echo ""
````
<img width="525" height="279" alt="image" src="https://github.com/user-attachments/assets/8a0dfe0e-c0c7-4d84-9ba0-3f86e71b066e" />

- Shows capability bitmasks for the shell process running the script.
- **CapInh (Inheritable)**: `0000000000000000` → No inheritable capabilities. Your shell won’t pass any capabilities to child processes.
- **CapPrm (Permitted)**: `0000000000000000` → No permitted capabilities. The process has no privileges it could potentially make effective.
- **CapEff (Effective)**: `0000000000000000` → No effective capabilities. Your shell is running as a normal user with no elevated privileges.
- **CapBnd (Bounding Set)**: `000001ffffffffff` → This is the upper limit of capabilities available on your kernel. It means the kernel supports a wide range of capabilities, but your process doesn’t currently hold any.
- **CapAmb (Ambient)**: `0000000000000000` → No ambient capabilities. Nothing persists across execve calls.




#### Kernel Capability Support
````
# KERNEL CAPABILITIES SUPPORT
echo "=== 5. KERNEL CAPABILITY SUPPORT ==="
if [ -f /proc/sys/kernel/cap-bound ]; then
    echo "Capability bounding set: $(cat /proc/sys/kernel/cap-bound)"
else
    echo "Kernel capability file not found"
fi
echo ""
````
<img width="726" height="226" alt="image" src="https://github.com/user-attachments/assets/0a5a78f8-e888-4168-9041-4aa0795214e9" />

- Displays the kernel’s bounding set (limits on what capabilities can be added).
- But in this we see not found.

#### Capability Management Tools
````
# CHECK FOR CAPABILITY TOOLS
echo "=== 6. CAPABILITY MANAGEMENT TOOLS ==="
which capsh 2>/dev/null && echo "capsh found: $(which capsh)"
which setcap 2>/dev/null && echo "setcap found: $(which setcap)"
which getcap 2>/dev/null && echo "getcap found: $(which getcap)"
echo ""
````
<img width="713" height="297" alt="image" src="https://github.com/user-attachments/assets/3610f0e3-d324-49d5-ab11-0f56743797a5" />

- Confirms if capability management tools (capsh, setcap, getcap) are installed.




### Quick Enumeration One-Liner:
- Find all capabilities quickly
````
getcap -r / 2>/dev/null | grep -v "=$" | while read line; do 
    file=$(echo $line | cut -d' ' -f1); 
    caps=$(echo $line | cut -d' ' -f2); 
    echo "[+] $file : $caps"; 
done
````
<img width="1785" height="373" alt="image" src="https://github.com/user-attachments/assets/3b7c703d-0ba4-45aa-b643-a19bf218e85a" />

- this command is a **capability enumeration script** that scans the filesystem, filters out empty entries, and prints a clean list of binaries with assigned capabilities.


---




## 6. Dangerous Capabilities Explained

### cap_dac_read_search & cap_dac_override
#### These allow reading/writing ANY file, regardless of permissions
- If /usr/bin/python3 has cap_dac_read_search:
````
sudo python3 -c "open('/etc/shadow').read()"
````
<img width="626" height="93" alt="image" src="https://github.com/user-attachments/assets/a45a1403-f5ce-4e0b-943e-406f077b23ba" />

- Check permsiion:
````
ls -l /etc/shadow
````
<img width="570" height="113" alt="image" src="https://github.com/user-attachments/assets/28c205a4-7696-458a-9662-70016550cf45" />

- Meaning only `root` and members of the `shadow` group can read it.

- Check if any binary has dangerous capabilities:
````
getcap -r / 2>/dev/null | grep cap_dac_read_search
````
<img width="1740" height="122" alt="image" src="https://github.com/user-attachments/assets/cde2e992-4a5a-454f-8eea-1e4013c4d965" />


-  If a binary has this capability, it could bypass file read restrictions.
- `cap_chown`: Change file ownership.
- `cap_dac_override`: Bypass file read/write/execute permission checks.
- `cap_dac_read_search`: Bypass directory read/search restrictions (dangerous for /etc/shadow).
- `cap_fowner`: Override file ownership checks.
- `cap_setgid / cap_setuid`: Change group/user IDs.
- `cap_sys_chroot`: Use chroot, potentially escape confinement.
- `cap_sys_ptrace`: Trace other processes (debugging, but exploitable).
- `cap_sys_admin`:  Extremely powerful, often considered “root equivalent.”
- We can show recruiters that you don’t just run enumeration scripts, we interpret the results and connect them to real attack surfaces.



### Others:
#### **cap_sys_admin**: 
- Very dangerous - allows many administrative operations
- Can mount filesystems, modify kernel parameters, etc.

- If a binary has cap_sys_admin, it can:
  - Mount / unmount filesystems
  - Perform swap operations
  - Set hostname
  - Many other privileged operations

#### **cap_sys_ptrace**:
- Allows debugging/attaching to any process.

- If /usr/bin/gdb has cap_sys_ptrace.
- Can attach to root processes and inject code.

- Exploitation:
````
gdb -p 1
````
<img width="794" height="480" alt="image" src="https://github.com/user-attachments/assets/fe0edf32-4125-4c07-be24-bc853f1fcdac" />

<img width="792" height="512" alt="image" src="https://github.com/user-attachments/assets/1b4621db-ec16-4992-b9e9-2c45d79388ff" />

<img width="879" height="767" alt="image" src="https://github.com/user-attachments/assets/ee4ff54f-3866-4433-bf48-853c23123b94" />

- type `q` to exit.

````
p/x $rax
````
<img width="214" height="126" alt="image" src="https://github.com/user-attachments/assets/a7cb6232-9d18-42ce-93cb-7afbdfffc7e8" />


- Attach to PID 1 (init, usually root)



























































